# python-21v
# unit 01

# Самостоятельная установка среды
## Установка Python на Windows
Скачать python с официального сайта. Заходим на https://python.org/downloads/windows/, выбираем "latest python release" и python 3.

## Установка Python на linux системы (ubuntu, linux mint и другие)

Откройте консоль (обычно ctrl+alt+t). Введите в консоли: python3

    Python 3.4.0 (default, Apr 11 2014, 13:05:11)
    [GCC 4.8.2] on linux
    Type "help", "copyright", "credits" or "license" for more information.
    >>>

у вас уже стоит python  
В противном случае нужно установить пакет *python3*:

    sudo apt-get install python3

### Python on Linux, Mac OS X, etc.

    ~/$ python
    >>> 1 + 1
    2

### Python on Windows

    C:\> python

    I. Install for Windows

    	1. Go to https://www.python.org/getit/windows/

    	2. Click on Latest Python 3 Release

    	3. Click on Windows x86 executable installer

    	4. Click Run

    	5. Check Install for all users and add Python 3 to path

    	6. Click Install Now

    	7. Look at Start -> All Apps and you'll see IDLE and Python 3

    	8. Go to https://atom.io to install Atom

    	9. Click Download Windows Installer

    	10. Click Run

    	11. Click Welcome and Open a Project and Open a Project

    	14. Right click and create a new folder

    	15. Call the folder PythonCode and click Select Folder

    	16. Click the x to close the Welcome, Settings and Welcome Guide tabs

    	17. Ctrl + Shift + + Increases the font size

    	18. Click Packages -> Command Palette -> Toggle

    	19. Type Install and click Install Packages and Themes

    	20. Type atom-runner and click install

    	21. Type print ("Hello World") and save the file as pythontut.py in the PythonCode folder

    	22. Click Alt - R to run the code

    	23. Try the following code to make sure you are running Python 3.5 or later

    		a. import sys
    		print (sys.version_info)

        24. Open IDLE from the start menu

    II. Install for Mac

    	1. Download Python at https://www.python.org/downloads

    	2. Click Download Python 3.5.1 or later

    	3. Click Open

    	4. Click continue a few times. Agree to the terms and install. You may have to enter your password.

    	5. Go to atom.io to download the Atom Text Editor

    	6. Open it and it will probably go in your Downloads folder. If so put it in your Apps folder which is at Macintosh/Applications

    	7. Open Atom and click Packages -> Command Palette -> Toggle

    	8. Type Install and click Install Packages and Themes

    	9. Type atom-runner and click Packages. Click Install next to atom-runner

    	10. Type print ("Hello World") in the file named untitled and save it as pythontut.py

    	11. Click Control r to run the code

    	12. Check the version of Python atom runner is using by running
    	import sys
    	print (sys.version_info)

    	13. If major doesn't equal 3 find the location of Python by typing which python3 in your terminal

    	14. In Atom click Atom -> Config... and enter this at the end and save
    	runner:
        scopes:
          python: "/Library/Frameworks/Python.framework/Versions/3.5/bin/python3"

        15. If you rerun the code in step 12 you'll see it is using Python 3 now

        16. You can run IDLE by typing idle3 in your terminal

How can I configure PATH. (path to my python is C:\Python34)


If you install Python you can choose "add Python to PATH". This will probably fix it. Try running the Python3.4 installer again and make sure you tick this box (it's off by default, if I remember correctly).


Right click the start menu, and select System. Then, hit "Advanced system settings" > "Environment Variables". Click on path, and hit edit. Select "New" and add the folder that your python executable is in. That should fix the problem.

Your other option is to reinstall python and select "add PYTHON to PATH" as Carpetsmoker suggested.
https://github.com/lsegal/atom-runner
Using

    Hit Ctrl+R (Alt+R on Win/Linux) to launch the runner for the active window.
    Hit Ctrl+Shift+R (Alt+Shift+R on Win/Linux) to run the currently selected text in the active window.
    Hit Ctrl+Shift+C to kill a currently running process.
    Hit Escape to close the runner window.


## Editing Python
Программный код на языке Python можно записать с помощью любого простого текстового редактора, который способен загружать и сохранять текст либо в кодировке ASCII, либо UTF-8. По умолчанию предполагается, что файлы с программным кодом на языке Python сохраняются в кодировке UTF-8, надмножестве кодировки ASCII, с помощью которой можно представить практически любой символ любого национального алфавита.

Файлы с программным кодом на языке Python обычно имеют расширение .ру, хотя в некоторых UNIX-подобных системах (таких как Linux и Mac OS X) некоторые приложения на языке Python не имеют расширения, а программы на языке Python с графическим интерфейсом, в частности в Windows и Mac OS X, обычно имеют расширение .pyw.

## Как писать программы
### Интерактивный режим
В основном интерпретатор выполняет команды построчно: пишешь строку, нажимаешь Enter, интерпретатор выполняет ее, наблюдаешь результат.

Работать в интерактивном режиме в ОС Linux можно в консоли. Для этого следует выполнить команду python. Запустится интерпретатор, где сначала выведется информация об интерпретаторе. Далее, последует приглашение к вводу (>>>).
### Запустите интерпретатор Питона.

    2 + 5
    3 * (5 - 8)
    2.4 + 3.0 / 2
    и т.д.

Наберите подобные примеры в интерактивном режиме (в конце каждого нажимайте Enter).

Ответ выдается сразу после нажатия Enter (завершения ввода команды).
Бывает, что в процессе ввода была допущена ошибка или требуется повторить ранее используемую команду. Чтобы не писать строку сначала, в консоли можно прокручивать список команд, используя для этого стрелки на клавиатуре.

Другой вариант работы в интерактивном режиме — это работа в среде разработки IDLE, у которой есть интерактивный режим работы.

### IDLE (Integrated DeveLopment Environment)
— это интегрированная среда разработки на языке Python, созданная с помощью библиотеки Tkinter. Поставляется вместе с Python и благодаря использованию Tkinter может использоваться на многих платформах, среди которых Windows, Mac OS, Unix-подобные python.org/idle — официальный сайт IDLE

Среда IDLE обеспечивает ключевые возможности:

- ввод выражений и программного кода на языке Python с получением результатов прямо в командной оболочке Python;
- предоставляет редактор программного кода с подсветкой синтаксиса языка Python и поддержкой функции оформления отступов и отладчик, который может использоваться в режиме пошагового выполнения программного кода, облегчая поиск и устранение ошибок.

Использование IDLE
------------------
Первое, что стоит сделать это определить свое рабочее место, то есть создать папку, в которой вы будете работать и экспериментировать. Второе,— это запустить интерактивную оболочку языка — IDLE.

После того как вы установили на свой компьютер Python, вы можете запустить IDLE в Windows, пройдя по следующему пути: Пуск → Все программы → Python 2.7 → IDLE (Python GUI). На экране появляется окно с заголовком Python Shell.

В меню File выберите пункт New Window. Появится окно, в котором мы запишем нашу однострочную программу:


print ('Hello World!')

Теперь ваша программа находится в редакторе IDLE, но перед тем как программу запустить, ее нужно сохранить. Выберите File, затем Save As и найдите в обозревателе папку, которую вы создали для программ. Введите название программы. Название может быть любым, но рекоммендуем вам выбрать hello.py, чтобы легче ориентироваться в  примерах. Не стоит забывать про расширение .py, IDLE может сохранять текст в различных форматах.
Как запустить программу
-----------------------
Для того, чтобы запустить программу, выбираем Run → Run Module или нажимаем F5. В окне IDLE, в котором мы оказались как только его запустили, мы увидим результат

Командная оболочка Python
-------------------------
особенно удобна при опробовании простых алгоритмов, фрагментов программного кода и регулярных выражений и может использоваться как очень мощный и гибкий калькулятор.

При желании для создания программ вы можете использовать простой текстовый редактор, а отладку выполнять посредством инструкций print().

В отличие от консольного варианта здесь можно наблюдать подсветку синтаксиса (в зависимости от значения синтаксической единицы она выделяется определенным цветом). Прокручивать список ранее введенных команд можно с помощью комбинаций Alt+N, Alt+P.

## Print - функция
Оператор print был заменён функцией print(), с именованными аргументами для замены большей части синтаксиса старого оператора print.

### Примеры:

    Python2: print "The answer is", 2*2
    Python3: print("The answer is", 2*2)
    Python2: print x,    # Запятая в конце подавляет перевод строки
    Python3: print(x, end=" ")  # Добавляет пробел вместо перевода строки
    Python2: print              # Печатает перевод строки
    Python3: print()            # Нужно вызвать функцию!
    Python2: print >>sys.stderr, "fatal error"
    Python3: print("fatal error", file=sys.stderr)
    Python2: print (x, y)       # Печатает repr((x, y))
    Python3: print((x, y))      # Не путать с print(x, y)!

Также вы можете настроить разделитель между элементами, например:

    >>> print("There are <", 2**32, "> possibilities!", sep="")
There are <4294967296> possibilities!

### Синтаксис
Конец строки является концом инструкции (точка с запятой не требуется).
Вложенные инструкции объединяются в блоки по величине отступов. Отступ может быть любым, главное, чтобы в пределах одного вложенного блока отступ был одинаков.

Используйте 4 пробела.
----------------------
Вложенные инструкции в Python записываются в соответствии с одним и тем же шаблоном, когда основная инструкция завершается двоеточием, вслед за которым располагается вложенный блок кода, обычно с отступом под строкой основной инструкции.

## Создание скриптов
### Кодировка исходного файла

- Кодировка Python должна быть UTF-8 (ASCII в Python 2).

- Файлы в ASCII (Python 2) или UTF-8 (Python 3) не должны иметь объявления кодировки.

В стандартной библиотеке, нестандартные кодировки должны использоваться только для целей тестирования, либо когда комментарий или строка документации требует упомянуть имя автора, содержащего не ASCII символы; в остальных случаях использование \x, \u, \U или \N - наиболее предпочтительный способ включить не ASCII символы в строковых литералах.

Начиная с версии python 3.0 в стандартной библиотеке действует следующее соглашение:
- все идентификаторы обязаны содержать только ASCII символы, и означать английские слова везде, где это возможно (во многих случаях используются сокращения или неанглийские технические термины).
- строки и комментарии тоже должны содержать лишь ASCII символы. Исключения составляют: (а) test case, тестирующий не-ASCII особенности программы, и (б) имена авторов.
- Авторы, чьи имена основаны не на латинском алфавите, должны транслитерировать свои имена в латиницу.

### Кодировки (PEP 263)
Код ядра python всегда должен использовать ASCII или Latin-1 кодировку (также известную как ISO-8859-1). Начиная с версии python 3.0, предпочтительной является кодировка UTF-8 (смотрите PEP 3120).

### Unicode Strings

    >>>
    >>> u'Hello World !'
    u'Hello World !'

Python Unicode-Escape encoding.  escape sequence \u0020

    >>>
    >>> u'Hello\u0020World !'
    u'Hello World !'
    >>>

    >>> ur'Hello\u0020World !'
    u'Hello World !'

    >>> ur'Hello\\u0020World !'
    u'Hello\\\\u0020World !'
    >>>

    >>> u"abc"
    u'abc'

    >>> str(u"abc")
    'abc'

    >>> u"äöü"
    u'\xe4\xf6\xfc'

    >>> str(u"äöü")
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-2: ordinal not in range(128)
    >>>

    >>> u"äöü".encode('utf-8')
    '\xc3\xa4\xc3\xb6\xc3\xbc'
    unicode() function
    >>>

    >>> unicode('\xc3\xa4\xc3\xb6\xc3\xbc', 'utf-8')
    u'\xe4\xf6\xfc'

    >>> u'Слово'
    u'\u0421\u043b\u043e\u0432\u043e'

    >>> u'Слово'.encode('utf8')
    '\xd0\xa1\xd0\xbb\xd0\xbe\xd0\xb2\xd0\xbe'

    >>> u'\xd0\xa1\xd0\xbb\xd0\xbe\xd0\xb2\xd0\xbe'
    u'\xd0\xa1\xd0\xbb\xd0\xbe\xd0\xb2\xd0\xbe'

    >>> u'\u0421\u043b\u043e\u0432\u043e'
    u'\u0421\u043b\u043e\u0432\u043e'

    >>> print u'\u0421\u043b\u043e\u0432\u043e'
    Слово

    >>> print u'Слово'
    Слово

    >>> print 'Слово'
    Слово

### Source Code Encoding

    # -*- coding: encoding -*-
    # -*- coding: cp-1252 -*-


# философия языка Python
Этот документ описывает соглашение о том, как писать код для языка python, включая стандартную библиотеку, входящую в состав python. Пожалуйста, посмотрите также на сопутствующий PEP (python enhanced proposal — заявки на улучшение языка python), описывающий, какого стиля следует придерживаться при написании кода на C в реализации языка python.

Аббревиатура «PEP» расшифровывается как Python Enhancement Proposal (предложение по расширению Python). Если кто-то желает изменить или дополнить язык Python, и его стремление пользуется широкой поддержкой сообщества, он посылает PEP с подробным описанием своего предложения, чтобы его можно было рассмотреть в официальном порядке; в некоторых случаях, как это произошло с PEP 3131, предложение принимается и реализуется. Все предложения PEP можно найти на странице www.py-thon.org/dev/peps/.

Этот документ создан на основе рекомендаций Гуидо ван Россума с добавлениями от Барри. Если где-то возникал конфликт, мы выбирали стиль Гуидо. И, конечно, этот PEP может быть неполным (фактически, он, наверное, никогда не будет закончен).

Ключевая идея Гуидо такова: код читается намного больше раз, чем пишется. Собственно, рекомендации о стиле написания кода направлены на то, чтобы улучшить читабельность кода и сделать его согласованным между большим числом проектов. В идеале, весь код будет написан в едином стиле, и любой сможет легко его прочесть. Как говорится в PEP 20 «Читабельность имеет значение».

Это руководство о согласованности и единстве. Согласованность с этим руководством очень важна. Согласованность внутри одного проекта еще важнее. А согласованность внутри модуля или функции — самое важное. Но важно помнить, что иногда это руководство неприменимо, и понимать, когда можно отойти от рекомендаций. Когда вы сомневаетесь, просто посмотрите на другие примеры и решите, какой выглядит лучше.

### Две причины, чтобы нарушить правила:
Когда применение правила сделает код менее читабельным даже для того, кто привык читать код, который следует правилам.
Чтобы писать в едином стиле с кодом, который уже есть в проекте и который нарушает правила (может быть, в силу исторических причин) — впрочем, это возможность подчистить чужой код.

# Дзэн Питона
Если интерпретатору Питона дать команду import this (импортировать "сам объект"), то выведется так называемый "Дзен Питона", иллюстрирующий идеологию и особенности данного языка. Глубокое понимание этого дзена приходит тем, кто сможет освоить язык Python в полной мере и приобретет опыт практического программирования.
1. Beautiful is better than ugly. Красивое лучше уродливого.
2. Explicit is better than implicit. Явное лучше неявного.
3. Simple is better than complex. Простое лучше сложного.
4. Complex is better than complicated. Сложное лучше усложнённого.
5. Flat is better than nested. Плоское лучше вложенного.
6. Sparse is better than dense. Разрежённое лучше плотного.
7. Readability counts. Удобочитаемость важна.
8. Special cases aren't special enough to break the rules. Частные случаи не настолько существенны, чтобы нарушать правила.
9. Although practicality beats purity. Однако практичность важнее чистоты.
10. Errors should never pass silently. Ошибки никогда не должны замалчиваться.
11. Unless explicitly silenced. За исключением замалчивания, которое задано явно.
12. In the face of ambiguity, refuse the temptation to guess. В случае неоднозначности сопротивляйтесь искушению угадать.
13. There should be one — and preferably only one — obvious way to do it. Должен существовать один — и, желательно, только один — очевидный способ сделать это.
14. Although that way may not be obvious at first unless you're Dutch. Хотя он может быть с первого взгляда не очевиден, если ты не голландец.
15. Now is better than never. Сейчас лучше, чем никогда.
16. Although never is often better than *right* now. Однако, никогда чаще лучше, чем прямо сейчас.
17. If the implementation is hard to explain, it's a bad idea. Если реализацию сложно объяснить — это плохая идея.
18. If the implementation is easy to explain, it may be a good idea. Если реализацию легко объяснить — это может быть хорошая идея.
19. Namespaces are one honking great idea — let's do more of those! Пространства имён — прекрасная идея, давайте делать их больше!

## Комментарии
Комментарии, которые противоречат коду, хуже, чем отсутствие комментариев. Всегда исправляйте комментарии, если меняете код!
Комментарии должны являться законченными предложениями. Если комментарий — фраза или предложение, первое слово должно быть написано с большой буквы, если только это не имя переменной, которая начинается с маленькой буквы (кстати, никогда не отступайте от этого правила для имен переменных).

Если комментарий короткий, можно опустить точку в конце предложения. Блок комментариев обычно состоит из одного или более абзацев, составленных из полноценных предложений, поэтому каждое предложение должно оканчиваться точкой.

Ставьте два пробела после точки в конце предложения.

Если вы пишете по-английски, не забывайте о Странке и Уайте (имеется в виду книга Strunk & White, “Elements of style”, которая является практически эталонным руководством по правильному написанию текстов на английском языке.)

Программисты, которые не говорят на английском языке, пожалуйста, пишите комментарии на английском, если только вы не уверены на 120 процентов, что ваш код никогда не будут читать люди, не знающие вашего родного языка.

### Блок комментариев
Блок комментариев обычно объясняет код (весь, или только некоторую часть), идущий после блока, и должен иметь тот же отступ, что и сам код. Каждая строчка такого блока должна начинаться с символа # и одного пробела после него (если только сам текст комментария не имеет отступа).

Абзацы внутри блока комментариев лучше отделять строкой, состоящей из одного символа #.

### Комментарии в строке с кодом
Старайтесь реже использовать подобные комментарии.

Такой комментарий находится в той же строке, что и инструкция. «Встрочные» комментарии должны отделяться хотя бы двумя пробелами от инструкции. Они должны начинаться с символа # и одного пробела.

Комментарии в строке с кодом не нужны и только отвлекают от чтения, если они объясняют очевидное. Не пишите вот так:

    x = x + 1                 # Увеличиваем X на один

Впрочем, иногда такие комметарии полезны:

    x = x + 1                  # Место для рамки окна

# Строки документации
Соглашения о написании хорошей документации (docstrings) увековечены в PEP 257.

Пишите документацию для всех модулей, функций, классов, методов, которые объявлены как public. Строки документации необязательны для не-public методов, но лучше написать, что делает метод. Комментарий нужно писать после строки с def.

PEP 257 объясняет, как правильно и хорошо документировать. Заметьте, очень важно, чтобы закрывающие """ стояли на отдельной строчке. А еще лучше, если перед ними будет ещё и пустая строка, например:

        """Return a foobang
        Optional plotz says to frobnicate the bizbaz first.

        """

Для однострочной документации можно оставить """ на той же строке.

# Основная инструкция:
## Вложенный блок инструкций
### Несколько специальных случаев

Иногда возможно записать несколько инструкций в одной строке, разделяя их точкой с запятой:

    a = 1; b = 2; print(a, b)

Допустимо записывать одну инструкцию в нескольких строках. Достаточно ее заключить в пару круглых, квадратных или фигурных скобок:

    if (a == 1 and b == 2 and
        c == 3 and d == 4):  # Не забываем про двоеточие
          print('spam' * 3)

Тело составной инструкции может располагаться в той же строке, что и тело основной, если тело составной инструкции не содержит составных инструкций. пример:

    if x > y: print(x)

## Идентификаторы и ключевые слова
Создавая элемент данных, мы можем либо присвоить его переменной, либо вставить в коллекцию. (когда в языке Python выполняется операция присваивания, в действительности происходит связывание ссылки на объект с объектом в памяти, который хранит данные.)

Имена, которые даются ссылкам на объекты, называются идентификаторами, или просто именами. Допустимый идентификатор в языке Python - это последовательность символов произвольной длины, содержащей «начальный символ» и ноль или более «символов продолжения». Такой идентификатор  должен следовать определенным правилам и соглашениям.

- Первое правило касается начального символа и символов продолжения.

Начальным символом может быть любой символ, который в кодировке Юникод рассматривается как принадлежащий диапазону алфавитных символов ASCII («а», «Ь», ..., «z», «А», «В», ..., «Z»), символ подчеркивания («__»), а также символы большинства национальных (не английских) алфавитов. Каждый символ продолжения может быть любым символом из тех, что пригодны в качестве начального символа, а также любым непробельным символом, включая символы, которые в кодировке Юникод считаются цифрами, такие как («О», «1», ..., «9»), и символ Каталана «•». Идентификаторы чувствительны к регистру, поэтому TAXRATE, Tax rate, TaxRate, taxRate и tax rate - это пять разных идентификаторов.

Точный перечень символов, допустимых для использования в качестве начального символа и символов продолжения, описывается в документации по языку Python (справочник «Language reference», раздел «Lexical analysis», подраздел «Identifiers and keywords»1) или в PEP 31312 (раздел «Supporting Non-ASCII Identifiers»).

- Второе правило гласит
Не использовать в качестве своих идентификаторов любые предопределенные имена.

Как определить, относится ли тот или иной идентификатор к этим категориям? В языке Python имеется встроенная функция dir(), которая возвращает список атрибутов объекта. Если эта функция вызывается без аргументов, она возвращает список встроенных атрибутов языка Python.

    dir()  ['__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__']

Атрибут builtins в действительности является модулем, в котором определены все встроенные атрибуты языка Python. Его можно использовать в качестве аргумента функции diг ():

    dir(builtins)

В списке присутствует более 130 имен. Имена, начинающиеся с символов верхнего регистра, являются именами встроенных исключений. Остальные имена представляют функции и типы данных.

PyLint (www.logilab.org/project/name/pylint). Этот инструмент поможет вам также выявлять множество других фактических или потенциальных проблем в программах на языке Python.

### соглашение касается использования символа подчеркивания (_).
Не должны использоваться имена, начинающиеся и заканчивающиеся двумя символами подчеркивания.

Символ подчеркивания сам по себе может использоваться в качестве идентификатора внутри интерактивной оболочки интерпретатора или в командной оболочке Python в переменной с именем _ сохраняется результат последнего вычисленного выражения. Во время выполнения обычной программы идентификатор _ отсутствует, если мы явно не определяем его в своем программном коде. Некоторые программисты любят использовать _ в качестве идентификатора переменной цикла в циклах for ... in, когда не требуется обращаться к элементам, по которым выполняются итерации. Например:

    for _ in (0, 1, 2, 3, 4, 5):
    print("Hello")

Но имейте в виду, что те, кто пишет программы, которые затем интернационализируются, часто используют идентификатор _ в качестве имени функции перевода.

Делается это, чтобы вместо необходимости писать всякий раз gettext.gettext("Translate me") можно было писать _("Translate me"). (Чтобы можно было выполнить такой вызов, мы сначала должны импортировать модуль gettext, чтобы получить доступ к функции gettext (), находящейся в этом модуле).


    pi = math.pi
    е = 0.0000001
    nueva_area = n * radio * radio
    if abs(nueva_area - vieja_area) < e:
    print("las areas han convergido")

Самый простой способ проверить допустимость идентификатора состоит в том, чтобы попробовать присвоить ему некоторое значение в интерактивной оболочке интерпретатора Python или в командной оболочке Python среды IDLE.

    stretch-factor = 1
    SyntaxError: can't assign to operator (...)
    (SyntaxError: невозможно выполнить присваивание оператору (...))

    2miles = 2
    SyntaxError: invalid syntax (...)

Попытка использовать недопустимый идентификатор вызывает исключение SyntaxError.

# Соглашения по именованию
Соглашения по именованию переменных в python немного туманны, поэтому их список никогда не будет полным — тем не менее, ниже мы приводим список рекомендаций, действующих на данный момент. Новые модули и пакеты должны быть написаны согласно этим стандартам, но если в какой-либо уже существующей библиотеке эти правила нарушаются, предпочтительнее писать в едином с ней стиле.

## Главный принцип

Имена, которые видны пользователю как часть общественного API должны следовать конвенциям, которые отражают использование, а не реализацию.

### Описание: Стили имен

Существует много разных стилей. Поможем вам распознать, какой стиль именования используется, независимо от того, для чего он используется.

### Обычно различают следующие стили:

- b (одиночная маленькая буква)
- B (одиночная заглавная буква)
- lowercase (слово в нижнем регистре)
- lower_case_with_underscores (слова из маленьких букв с подчеркиваниями)
- UPPERCASE (заглавные буквы)
- UPPERCASE_WITH_UNDERSCORES (слова из заглавных букв с подчеркиваниями)
- CapitalizedWords (слова с заглавными буквами, или CapWords, или CamelCase). Замечание: когда вы используете аббревиатуры в таком стиле, пишите все буквы аббревиатуры заглавными — HTTPServerError лучше, чем HttpServerError.
- mixedCase (отличается от CapitalizedWords тем, что первое слово начинается с маленькой буквы)
- Capitalized_Words_With_Underscores (слова с заглавными буквами и подчеркиваниями — уродливо!)

Ещё существует стиль, в котором имена, принадлежащие одной логической группе, имеют один короткий префикс. Этот стиль редко используется в python. Например, функция os.stat() возвращает кортеж, имена в котором традиционно имеют вид st_mode, st_size, st_mtime и так далее. (Так сделано, чтобы подчеркнуть соответствие этих полей структуре системных вызовов POSIX, что помогает знакомым с ней программистам).

В библиотеке X11 используется префикс Х для всех public-функций. В python этот стиль считается излишним, потому что перед полями и именами методов стоит имя объекта, а перед именами функций стоит имя модуля.

В дополнение к этому, используются следующие специальные формы записи имен с добавлением символа подчеркивания в начало или конец имени:

_single_leading_underscore: слабый индикатор того, что имя используется для внутренних нужд. Например, from M import * не будет импортировать объекты, чьи имена начинаются с символа подчеркивания.

single_trailing_underscore_: используется по соглашению для избежания конфликтов с ключевыми словами языка python, например:

    Tkinter.Toplevel(master, class_='ClassName')

__double_leading_underscore: изменяет имя атрибута класса, то есть в классе FooBar поле __boo становится _FooBar__boo.

__double_leading_and_trailing_underscore__ (двойное подчеркивание в начале и в конце имени): магические методы или атрибуты, которые находятся в пространствах имен, управляемых пользователем. Например, __init__, __import__ или __file__. Не изобретайте такие имена, используйте их только так, как написано в документации.

### Предписания: соглашения по именованию

### Имена, которых следует избегать
Никогда не используйте символы l (маленькая латинская буква «эль»), O (заглавная латинская буква «о») или I (заглавная латинская буква «ай») как однобуквенные идентификаторы.

В некоторых шрифтах эти символы неотличимы от цифры один и нуля. Если очень нужно l, пишите вместо неё заглавную L.


## Внешний вид кода
### Отступы

Используйте 4 пробела на каждый уровень отступа.

Продолжительные строки должны выравнивать обернутые элементы либо вертикально, используя неявную линию в скобках (круглых, квадратных или фигурных), либо с использованием висячего отступа. При использовании висячего отступа следует применять следующие соображения: на первой линии не должно быть аргументов, а остальные строки должны четко восприниматься как продолжение линии.


    # Выровнено по открывающему разделителю
    foo = long_function_name(var_one, var_two,
                             var_three, var_four)

    # Больше отступов включено для отличения его от остальных
    def long_function_name(
            var_one, var_two, var_three,
            var_four):
        print(var_one)
    # Нет необходимости в большем количестве отступов.
    foo = long_function_name(
      var_one, var_two,
      var_three, var_four)

Закрывающие круглые/квадратные/фигурные скобки в многострочных конструкциях могут находиться под первым непробельным символом последней строки списка, например:

    my_list = [
        1, 2, 3,
        4, 5, 6,
        ]
    result = some_function_that_takes_arguments(
        'a', 'b', 'c',
        'd', 'e', 'f',
        )

либо быть под первым символом строки, начинающей многострочную конструкцию:

    my_list = [
        1, 2, 3,
        4, 5, 6,
    ]
    result = some_function_that_takes_arguments(
        'a', 'b', 'c',
        'd', 'e', 'f',
    )

## Табуляция или пробелы?

Пробелы - самый предпочтительный метод отступов.

Табуляция должна использоваться только для поддержки кода, написанного с отступами с помощью табуляции.

Python 3 запрещает смешивание табуляции и пробелов в отступах.
--------------------------------------------------------------
Python 2 пытается преобразовать табуляцию в пробелы.
----------------------------------------------------
Когда вы вызываете интерпретатор Python 2 в командной строке с параметром -t, он выдает предупреждения (warnings) при использовании смешанного стиля в отступах, а запустив интерпретатор с параметром -tt, вы получите в этих местах ошибки (errors). Эти параметры очень рекомендуются!
### Максимальная длина строки

Ограничьте длину строки максимум 79 символами.

Для более длинных блоков текста с меньшими структурными ограничениями (строки документации или комментарии), длину строки следует ограничить 72 символами.

Ограничение необходимой ширины окна редактора позволяет иметь несколько открытых файлов бок о бок, и хорошо работает при использовании инструментов анализа кода, которые предоставляют две версии в соседних столбцах.

Некоторые команды предпочитают большую длину строки. Для кода, поддерживающегося исключительно или преимущественно этой группой, в которой могут прийти к согласию по этому вопросу, нормально увеличение длины строки с 80 до 100 символов (фактически увеличивая максимальную длину до 99 символов), при условии, что комментарии и строки документации все еще будут 72 символа.

Стандартная библиотека Python консервативна и требует ограничения длины строки в 79 символов (а строк документации/комментариев в 72).

Предпочтительный способ переноса длинных строк является использование подразумеваемых продолжений строк Python внутри круглых, квадратных и фигурных скобок. Длинные строки могут быть разбиты на несколько строк, обернутые в скобки. Это предпочтительнее использования обратной косой черты для продолжения строки.

Обратная косая черта все еще может быть использована время от времени. Например, длинная конструкция with не может использовать неявные продолжения, так что обратная косая черта является приемлемой:

    with open('/path/to/some/file/you/want/to/read') as file_1, \
            open('/path/to/some/file/being/written', 'w') as file_2:
        file_2.write(file_1.read())

## Пустые строки

Отделяйте функции верхнего уровня и определения классов двумя пустыми строками.

Определения методов внутри класса разделяются одной пустой строкой.

Дополнительные пустые строки возможно использовать для разделения различных групп похожих функций. Пустые строки могут быть опущены между несколькими связанными однострочниками (например, набор фиктивных реализаций).

Используйте пустые строки в функциях, чтобы указать логические разделы.

Python расценивает символ control+L как незначащий (whitespace), и вы можете использовать его, потому что многие редакторы обрабатывают его как разрыв страницы — таким образом логические части в файле будут на разных страницах. Однако, не все редакторы распознают control+L и могут на его месте отображать другой символ.

## Импорты

Каждый импорт, как правило, должен быть на отдельной строке.

    import os
    import sys

В то же время, можно писать так:

    from subprocess import Popen, PIPE


Импорты всегда помещаются в начале файла, сразу после комментариев к модулю и строк документации, и перед объявлением констант.

Импорты должны быть сгруппированы в следующем порядке:

- импорты из стандартной библиотеки
- импорты сторонних библиотек
- импорты модулей текущего проекта

Вставляйте пустую строку между каждой группой импортов.

Указывайте спецификации __all__ после импортов.

Рекомендуется абсолютное импортирование, так как оно обычно более читаемо и ведет себя лучше если импортируемая система настроена неправильно (например, когда каталог внутри пакета заканчивается на sys.path):

    import mypkg.sibling
    from mypkg import sibling
    from mypkg.sibling import example

Тем не менее, явный относительный импорт является приемлемой альтернативой абсолютному импорту, особенно при работе со сложными пакетами, где использование абсолютного импорта было бы излишне подробным:

    from . import sibling
    from .sibling import example

В стандартной библиотеке следует избегать сложной структуры пакетов и всегда использовать абсолютные импорты.

Неявные относительно импорты никогда не должны быть использованы, и были удалены в Python 3.

### Пробелы в выражениях и инструкциях
Избегайте использования пробелов в следующих ситуациях:

Непосредственно внутри круглых, квадратных или фигурных скобок.

    spam(ham[1], {eggs: 2})


Непосредственно перед запятой, точкой с запятой или двоеточием:

    if x == 4: print(x, y); x, y = y, x

Сразу перед открывающей скобкой, после которой начинается список аргументов при вызове функции:

    spam(1)

Сразу перед открывающей скобкой, после которой следует индекс или срез:


    dict['key'] = list[index]

Использование более одного пробела вокруг оператора присваивания (или любого другого) для того, чтобы выровнять его с другим:



    x = 1
    y = 2
    long_variable = 3


### Другие рекомендации

Всегда окружайте эти бинарные операторы одним пробелом с каждой стороны: присваивания (=, +=, -= и другие), сравнения (==, <, >, !=, <>, <=, >=, in, not in, is, is not), логические (and, or, not).

Если используются операторы с разными приоритетами, попробуйте добавить пробелы вокруг операторов с самым низким приоритетом. Используйте свои собственные суждения, однако, никогда не используйте более одного пробела, и всегда используйте одинаковое количество пробелов по обе стороны бинарного оператора.

    i = i + 1
    submitted += 1
    x = x*2 - 1
    hypot2 = x*x + y*y
    c = (a+b) * (a-b)

Не используйте пробелы вокруг знака =, если он используется для обозначения именованного аргумента или значения параметров по умолчанию.


    def complex(real, imag=0.0):
        return magic(r=real, i=imag)


Не используйте составные инструкции (несколько команд в одной строке).



    if foo == 'blah':
        do_blah_thing()
    do_one()
    do_two()
    do_three()


Иногда можно писать тело циклов while, for или ветку if в той же строке, если команда короткая, но если команд несколько, никогда так не пишите. А также избегайте длинных строк!


## Советы по программированию на Python

### PyChecker

Используйте PyChecker для проверки своего кода

PyChecker — это инструмент для нахождения багов в исходниках Python-программ. Он находит проблемы, которые были бы выявлены компилятором менее динамичных языков, таких как С и С++. В силу динамической природы языка Python, некоторые предупреждения могут быть несправедливыми, однако ложные предупреждения не должны встречаться часто.


Отлавливает трудновыявляемые ошибки, такие как: ошибки типов, использование переменных перед их объявлением и т.д.


PyChecker не идеален. Чтобы получить все его преимущества нам нужно:
- Писать с оглядкой на него
- Подавить его предупреждения
- Исправлять ошибки
- Либо не обращать внимания на них внимания

Убедитесь, что Вы запустили PyChecker с вашим кодом. Для того чтобы узнать как запустить PyChecker, загляните на его домашнюю страницу. Чтобы подавить предупреждения, вам нужно создать переменную __pychecker__ в данном модуле и указать какие ошибки должны подавляться. Например:

    __pychecker__ = 'no-callinit no-classattr'

Подавление предупреждений таким путем имеет преимущество следующего плана — мы можем с легкостью производить поиск по подавлениям и возвращаться к ним. Вы можете познакомиться со списком предупреждений PyChecker, если наберете:

    pychecker -- help

Неиспользуемые аргументы могут быть опущены при помощи '_', как наименования неиспользуемого аргумента, либо префикса аргумента «unused_». В ситуациях когда изменение имени аргумента невозможно, Вы можете упомянуть их в начале функции. Например:

    def foo(a, unused_b, unused_c, d=None, e=None):
        _ = d, e
        return a


# Глобальные переменные

Избегайте использования глобальных переменных

Переменные, которые определены на уровне модуля.

Иногда полезны.

Можно нечаянно изменить поведение модуля при импорте, т.к. присваивание переменных уровня модуля уже завершено когда модуль импортируется.

Избегайте использования глобальных переменных в пользу переменных класса.

### Несколько исключений ниже:
### Стандартные настройки скриптов.
Константы уровня модуля. Например, PI = 3.14159. Константы должны быть именованы с использованием только заглавных букв и символа подчеркивания.

Иногда полезно использовать глобальные переменные, чтобы кэшировать значения, необходимые для функции или возвращаемые функцией.


# Модуль keyword

keyword.kwlist - список всех доступных ключевых слов (почему не кортеж, непонятно).
keyword.iskeyword(строка) - является ли строка ключевым словом.

## Ключевые слова

- False - ложь.
- True - правда.
- None - "пустой" объект.
- and - логическое И.
- with / as - менеджер контекста.
- assert условие - возбуждает исключение, если условие ложно.
- break - выход из цикла.
- class - пользовательский тип, состоящий из методов и атрибутов.
- continue - переход на следующую итерацию цикла.
- def - определение функции.
- del - удаление объекта.
- elif - в противном случае, если.
- else - см. for/else или if/else.
- except - перехватить исключение.
- finally - вкупе с инструкцией try, выполняет инструкции независимо от того, было ли исключение или нет.
- for - цикл for.
- from - импорт нескольких функций из модуля.
- global - позволяет сделать значение переменной, присвоенное ей внутри функции, доступным и за пределами этой функции.
- if - если.
- import - импорт модуля.
- in - проверка на вхождение.
- is - ссылаются ли 2 объекта на одно и то же место в памяти.
- lambda - определение анонимной функции.
- nonlocal - позволяет сделать значение переменной, присвоенное ей внутри функции, доступным в объемлющей инструкции.
- not - логическое НЕ.
- or - логическое ИЛИ.
- pass - ничего не делающая конструкция.
- raise - возбудить исключение.
- return - вернуть результат.
- try - выполнить инструкции, перехватывая исключения.
- while - цикл while.
- yield - определение функции-генератора.

Первая программа
================

Первая задача, которую мы рассмотрим — школьная задача о вертикальном движении мяча, подброшенного в воздух. Мы знаем математическую модель, описывающую такое движение и можем найти координату y, в которой оказывается мячик в момент времени t:
y ( t ) = v 0 t − g t 2 2 {\displaystyle y(t)=v_{0}t-{\frac {gt^{2}}{2}}}   (1.1)

где v0 — начальная скорость мячика, g — ускорение свободного падения и t — время. Заметим, ось y выбрана так, что мячик в начальный момент времени (t = 0) находится в точке с координатой y = 0. Чтобы посмотреть сколько времени займет у мячика вернуться в эту же координату (y = 0), надо с одной стороны в выражении (1.1) правую часть приравнять нулю, с другой — вынести переменную t:

  v 0 t − g t 2 2 = t ( v 0 − g t 2 ) = 0 {\displaystyle ~v_{0}t-{\frac {gt^{2}}{2}}=t(v_{0}-{\frac {gt}{2}})=0}

t = 0 , t = 2 v 0 g {\displaystyle t=0,t={\frac {2v_{0}}{g}}}

Таким образом, мы определили, что возможное время полета мяча задается интервалом времени t 2 [ 0 , 2 v 0 g ] {\displaystyle t{\mathcal {2}}[0,{\frac {2v_{0}}{g}}]} .


Программа как калькулятор

Наша первая программа будет находить координату мяча для выбранных нами значений начальной скорости, ускорения и момента времени. Соответственно выберем v0 = 5 м/с, g = 9.81 м/с2, мяч вернется к нам в руки после t = 2v0/g ≈ 1 c. Это значит, что нам интересен только интервал времени [0, 1]. Представим, мы хотим узнать высоту на которой окажется мяч в момент времени t = 0.6 c. Арифметическое выражение и его аналог в виде однострочной программы на Python представлены далее:


y ( 0.6 ) = 5 ∗ 0.6 − 9.81 ∗ 0.6 2 2 {\displaystyle y(0.6)=5*0.6-{\frac {9.81*0.6^{2}}{2}}}

print (5*0.6 - 0.5*9.81*0.6**2)


Четыре стандартных арифметических операции в Python, как во многих других языках программирования записываются так +, -, * и /. Возведение в степень записывается двумя звездочками: **.

О программах и программировании

Компьютерная программа — это всего лишь набор инструкций для компьютера, написанных на компьютерном языке. Большинство компьютерных языков выглядят похожими на английский, но они гораздо проще. Число зарезервированных слов и устойчивых выражений сильно ограничено, поэтому чтобы совершить какую-то операцию, мы должны комбинировать эти слова и выражения. Текст программы, содержащий эти инструкции, расположен в одном или более файлах. Компьютер делает только то, что программа говорит ему делать.

Другое значение слова "программа" — это файл, который запускается для выполнения какой-то задачи. Иногда это файл с инструкциями, а иногда это "перевод" инструкций на языке программирования в более понятный и потому более эффективный компьютерный язык, который сложно понять человеку. Все программы в наших первых уроках состоят из короткого текста, расположенного в одном файле. Другие программы, которые вы часто используете, например, ваш браузер, с помощью которого вы читаете этот текст, состоят из большого числа файлов, написанных множеством людей за несколько лет.

Программирование это написание программ, но этот процесс — не просто задание правильных инструкций, записанных в файле. Во-первых, мы должны понять, как проблема может быть решена заданием инструкций компьютеру. Это обычно наиболее сложная вещь в программировании. Во-вторых, мы должны правильно перевести наши инструкции в язык программирования и записать соответствующий текст в файл. В-третьих, мы должны запустить программу, проверить правильность результатов, и тут обычно наступает "в-четвертых" — найти и исправить ошибки. Овладение всем этим процессом требует долгой тренировки, которая заключается в написании большого числа работающих программ, для начала — решении упражнений этого курса.
Инструменты для написания программ, установка Python

Специальный редактор программ на Python поставляется вместе с интерпретатором языка. Этот редактор называется IDLE и инсталлируется под этим же именем. С этого момента, если вы еще этого не сделали, рекомендую вам скачать Python 2.7 c официального сайта. Обращаю ваше внимание, что в этом курсе мы будем работать именно с этой версией языка (2.7). Стандарт Python 3 относится к новым разработкам, под которые еще не переписаны те библиотеки, что мы будем использовать.


Использование IDE
=================




Естественно в нашей простой программе мы можем подставить любые другие интересующие нас начальную скорость и момент времени и повторить те же действия. Выберем теперь v0 = 1, t = 0.1. Наша программа примет следующий вид:


print (1*0.1 - 0.5*9.81*0.1**2)


Сохранив файл и запустив программу заново, в новых условиях получаем новую координату мячика:


0.05095

Проверка результатов

Мы должны всегда внимательно контролировать, что программа дает правильные результаты. Вы увидите что в большинстве случаев, пока вы еще не набрались опыта программирования, выходные данные будут оказываться неверными и вам придется искать ошибки. В нашем первом примере для того, чтобы проконтролировать действия программы, мы можем просто использовать калькулятор и подставить заданные значения в формулу. Для t = 0.6 and v0 = 5, калькулятор покажет 1.2342. Это и будет означать, что наше решение работает правильно. Сейчас мы обсуждаем очень простые вещи, но пропуская их и не видя друг друга, мы можем ошибаться в нашем взаимном понимании.

Переменные

Конечно, простая подстановка чисел не очень интересная задача, поскольку как мы только что убедились, на такое способен и калькулятор. Если мы хотим узнать y(t) для многих значений времени t, нам бы требовалось изменять t в двух местах. А если еще нужно изменить значение v0, то мы можем и вовсе запутаться и совершить ошибку. Такие изменения проще оформлять в виде переменных. Большинство языков программирования, в том числе и Python используют переменные также как это делается в математике. Это означает, что мы можем задать v0, g, t и даже y как переменные нашей программы. Первые три мы будем задавать, придавая им какие-то численные значения, а последнюю выражать через них.

Альтернативная версия нашей программы с использованием переменных будет выглядеть так:


v0 = 5
g = 9.81
t = 0.6
y = v0*t - 0.5*g*t**2
print (y)


Заметим, что так программу гораздо более удобно читать и становится понятно что она делает, поскольку ее вид очень близок к тому как мы математически записали выражение (1.1). Программа также более безопасна относительно наших исправлений, потому что мы видим к чему относится изменяемое нами число. К тому же, нам достаточно изменить переменную (например, t) всего лишь в одном месте, в остальных местах, где она появится она будет ссылаться на введенное нами значение.


Имена переменных


initial_velocity = 5
acceleration_of_gravity = 9.81
TIME = 0.6
VerticalPositionOfBall = initial_velocity*TIME - 0.5*acceleration_of_gravity*TIME**2
print  (VerticalPositionOfBall)


Очевидно, что такой вариант программы сложнее читать, чем предыдущий с переменными v0, g, t, y. Старайтесь давать переменным ясные короткие имена, отражающие проблему в терминах этой задачи. Если две переменные претендуют на одно и то же название, старайтесь дать более короткое название наиболее встречаемой в тексте программы. Но не уходите в крайности.



# Program for computing the height of a ball thrown up in the air.  
v0 = 5     # Initial velocity
g = 9.81   # Acceleration of gravity
t = 0.6    # Time
y = v0*t - 0.5*g*t**2  # Vertical position
print  (y)


Приучайте себя к продумыванию названий переменных и написанию комментариев. Это значительно облегчает вам жизнь, когда вы открываете файл вашей сложной программы через пару месяцев, работая над новым проектом и уже не помните, что значит эта константа или для чего вы ввели эту функцию. Никогда не объясняйте того, что ясно из самого языка, не дублируйте в комментариях код. Разработчики языка тщательно следят за стилем языка и предлагают и для написания комментариев несколько следующих рекомендаций. Данные и другие рекомендации вы можете потом прочитать в файле "Стиль кода в языке Python", размещенной в ссылках на главной странице курса.

Комментарии, которые противоречат коду, хуже, чем отсутствие комментариев. Всегда исправляйте комментарии, если меняете код!

Комментарии должны являться законченными предложениями. Если комментарий — фраза или предложение, первое слово должно быть написано с большой буквы, если только это не имя переменной, которая начинается с маленькой буквы.

Если комментарий короткий, можно опустить точку в конце предложения. Блок комментариев обычно состоит из одного или более абзацев, составленных из полноценных предложений, поэтому каждое предложение должно оканчиваться точкой.

Ставьте два пробела после точки в конце предложения.

Программисты, которые не говорят на английском языке, пожалуйста, пишите комментарии на английском, если только вы не уверены на 120 процентов, что ваш код никогда не будут читать люди, не знающие вашего родного языка.

Блок комментариев обычно объясняет код (весь, или только некоторую часть), идущий после блока, и должен иметь тот же отступ, что и сам код. Каждая строчка такого блока должна начинаться с символа # и одного пробела после него (если только сам текст комментария не имеет отступа). Абзацы внутри блока комментариев лучше отделять строкой, состоящей из одного символа #.
Форматирование текста и чисел

Вместо того, чтобы только выводить значение y в нашей первой программе, мы бы теперь хотели написать более информативный текст, в котором передавали репортаж с места наших физико-математических событий, что-то вроде:


At t=0.6 s, the height of the ball is 1.23 m.


где бы мы также аккуратно форматировали числа (допустим, нам интересно значение до сотых долей метра — сантиметров). Такой результат достигается с помощью специальных выражений, часто называемых printf-форматированием наподобие аналогичного форматирования в языке С. Для начинающего программиста, синтаксис такого форматирования может показаться неуклюжим, но он вполне прост для изучения и очень удобен и гибок для работы. Задача выше решается так:


print ('At t=%g s, the height of the ball is %.2f m.' % (t, y))


Посмотрим, что здесь написано. Инструкция print выводит на экран то что заключено в кавычки (как одинарные: ', так и двойные: "), которые показывают, что это строка. Сама строка отформатирована в printf-стиле. Это означает, что в строке имеются два "разъема", обозначенные знаком процента, здесь это %g и %.2f, в которые программа ждет, что вы вставите переменные, по форме подходящие для этих разъемов. И, после того как строка закончилась, мы после знака процента перечисляем эти самые переменные в том порядке, как мы их ожидаем увидеть в строке. Первая переменная t идет в первый разъем, символ после процента (g) показывает что переменная это число и говорит как это число надо отформатировать - записать как можно более компактно. Вторая переменная y идет во второй разъем, форматирование .2f показывает, что это число с плавающей (float) точкой, и после точки надо оставить два десятичных знака.

Для полноты приведем теперь как выглядит наша программа с форматированным выводом:


# Program for computing the height of a ball thrown up in the  air

v0 = 5
g = 9.81
t = 0.6
y = v0*t - 0.5*g*t**2
print ('At t=%g s, the height of the ball is %.2f m.' % (t, y))


Существует множество других методов форматирования, то есть того, что мы указываем после знака процента. Например, часто используется scientiﬁc notation, форматирование через символ e или E в тех случаях, когда числа имеют большие порядки. Например, в таком формате удобно представить заряд электрона, равный 1.6·10-19 Кл, в scientiﬁc notation можно записать так: q = 1.6e-19.

В рассмотренном нами f-формате, числа до и после точки показывают соответственно сколько символов отводится под число и сколько знаков следует после точки. Форматирование с буквой g выводит в "научном" формате, через e для очень больших и очень маленьких чисел и десятичный вывод для остальных, то есть как и было сказано, выводит числа в наиболее компактном варианте.

Для понимания пара примеров: формат 10.4f и 14.6E. Первый означает, что это число с плавающей точкой, записанное в десятичном формате с четырьмя знаками после точки, а все число вместе с точкой занимает 10 символов. Во втором случае мы имеем число с плавающей точкой, после точки точность нашего числа 6 знаков, места в тексте мы отводим ему 14 символов.

Приведем здесь наиболее часто встречающиеся методы форматирования:


 %s     строка
 %d     целое число
 %f     десятичное представление с шестью знаками после запятой
 %e     "научное" представление
 %g     компактное представление десятичного числа
 %xz    вывод в формате z в поле ширины x, выравнивание по правой стороне
 %-xz   вывод в формате z в поле ширины x, выравнивание по левой стороне
 %.yz   вывод в формате z с y знаков после запятой
 %x.yz  вывод в формате z с y знаков после запятой в поле ширины x
 %%     вывод знака процента


Часто мы хотим, чтобы текст располагался в несколько линий. Возможно, как минимум, два способа как мы можем это осуществить. Первый — для перехода на новую строку используется специальное сочетание символов — \n. Когда интерпретатор встречает это сочетание, происходит то же, что когда вы нажимаете Enter. Другой способ — использование тройных кавычек, как и одинарных, так и двойных. В этом случае текст выводится как он введен, специальные символы, начинающиеся с \ игнорируются. Следующие два текста программ


print ('y(t) is\nthe position of\nour ball.')


print ("""y(t) is
the position of
our ball.""")


выводят на экран одно и то же:


y(t) is
the position of
our ball.
Чему мы научились

Теперь мы знаем как написать, сохранить и запустить программу. При этом с разумно выбранными именами переменных и поясняющими комментариями мы сможем понять, что делает наша программа и через пять лет. Программа не просто выводит число, а может и рассказать нам, что сделано. Да и сами числа мы можем вывести с требуемой точностью, не думая о лишних знаках после запятой. Правда в том, сможете ли вы все это? Вы убедитесь в этом, решив следующие упражнения.


# Programming involves listing all the things that must happen to solve a problem
# When writing a program first determine step-by-step what needs to happen
# Then convert those steps into the language being Python in this situation

# Every language has the following
# 1. The ability to accept input and store it in many ways
# 2. The ability to output information to the screen, files, etc.
# 3. The ability to conditionally do one thing or another thing
# 4. The ability to do something multiple times
# 5. The ability to make mathematical calculations
# 6. The ability to change data
# 7. (Object Oriented Programming) Model real world objects using code

# ---------- Hello World ----------

# Ask the user to input their name and assign it to the name variable
# Variable names start with a letter or _ and then can contain numbers
# Names are case sensitive so name is not the same as Name
name = input('What is your name ')

# Print out Hello followed by the name they entered
print('Hello ', name)

# You can't use the following for variable names
# and, del, from, not, while, as, elif, global,
# or, with, assert, else, if, pass, yield, break,
# except, import, print, class, exec, in, raise,
# continue, finally, is, return, def, for, lambda,
# try

# Single line comments are ignored by the interpreter
'''
So are multiline comments
'''

# ---------- MATH ON 2 VALUES ----------

# Ask the user to input 2 values and store them in variables num1 and num2
# split() splits input using whitespace
num1, num2 = input('Enter 2 numbers : ').split()

# Convert strings into regular numbers (integers)
num1 = int(num1)
num2 = int(num2)

# Add the values entered and store in sum
sum = num1 + num2

# Subtract the values and store in difference
difference = num1 - num2

# Multiply the values and store in product
product = num1 * num2

# Divide the values and store in quotient
quotient = num1 / num2

# Use modulus on the values to find the remainder
remainder = num1 % num2

# Print your results
# format() loads the variable values in order into the {} placeholders
print("{} + {} = {}".format(num1, num2, sum))
print("{} - {} = {}".format(num1, num2, difference))
print("{} * {} = {}".format(num1, num2, product))
print("{} / {} = {}".format(num1, num2, quotient))
print("{} % {} = {}".format(num1, num2, remainder))

# ---------- PROBLEM : MILES TO KILOMETERS ----------
# Sample knowing that kilometers = miles * 1.60934
# Enter Miles 5
# 5 miles equals 8.0467 kilometers

# Ask the user to input miles and assign it to the miles variable
miles = input('Enter Miles ')

# Convert from string to integer
miles = int(miles)

# Perform calculation by multiplying 1.60934 times miles
kilometers = miles * 1.60934

# Print results using format()
print("{} miles equals {} kilometers".format(miles, kilometers))

# ---------- CALCULATOR ----------
# Receive 2 numbers separated by an operator and show a result
# Sample
# Enter Calculation: 5 * 6
# 5 * 6 = 30

# Store the user input of 2 numbers and an operator
num1, operator, num2 = input('Enter Calculation: ').split()

# Convert strings into integers
num1 = int(num1)
num2 = int(num2)

# If, else if (elif) and else execute different code depending on a condition
if operator == "+":
    print("{} + {} = {}".format(num1, num2, num1+num2))

# If the 1st condition wasn't true check if this one is
elif operator == "-":
    print("{} - {} = {}".format(num1, num2, num1 - num2))
elif operator == "*":
    print("{} * {} = {}".format(num1, num2, num1 * num2))
elif operator == "/":
    print("{} / {} = {}".format(num1, num2, num1 / num2))

# If none of the above conditions were true then execute this by default
else:
    print("Use either + - * or / next time")

# Other conditional operators
# > : Greater than
# < : Less than
# >= : Greater than or equal to
# <= : Less than or equal to
# != : Not equal to

# ---------- IS BIRTHDAY IMPORTANT ----------
# We'll provide different output based on age
# 1 - 18 -> Important
# 21, 50, > 65 -> Important
# All others -> Not Important

# eval() converts a string into an integer if it meets the guidelines
age = eval(input("Enter age: "))

# Logical operators can be used to combine conditions
# and : If both are true it returns true
# or : If either are true it returns true
# not : Converts true into false and vice versa

# If age is both greater than or equal to 1 and less than or equal to 18 it is true
if (age >= 1) and (age <= 18):
    print("Important Birthday")

# If age is either 21 or 50 then it is true
elif (age == 21) or (age == 50):
    print("Important Birthday")

# We check if age is less than 65 and then convert true to false or vice versa
# This is the same as if we put age > 65
elif not(age < 65):
    print("Important Birthday")
else:
    print("Sorry Not Important")

# ---------- PROBLEM : DETERMINE GRADE ----------
# If age 5 go to kindergarten
# Ages 6 through 17 goes to grades 1 through 12
# If age is greater then 17 then say go to college
# Try to complete with 10 or less lines

# Ask for the age
age = eval(input("Enter age: "))

# Handle if age < 5
if age < 5:
    print("Too Young for School")

# Special output just for age 5
elif age == 5:
    print("Go to Kindergarten")

# Since a number is the result for ages 6 - 17 we can check them all
# with 1 condition
# Use calculation to limit the conditions checked
elif (age > 5) and (age <= 17):
    grade = age - 5
    print("Go to {} grade".format(grade))

# Handle everyone else
else:
    print("Go to College")
