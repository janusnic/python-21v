# python-21v
# unit 01

## Editing Python
Программный код на языке Python можно записать с помощью любого простого текстового редактора, который способен загружать и сохранять текст либо в кодировке ASCII, либо UTF-8. По умолчанию предполагается, что файлы с программным кодом на языке Python сохраняются в кодировке UTF-8, надмножестве кодировки ASCII, с помощью которой можно представить практически любой символ любого национального алфавита.

Файлы с программным кодом на языке Python обычно имеют расширение .ру, хотя в некоторых UNIX-подобных системах (таких как Linux и Mac OS X) некоторые приложения на языке Python не имеют расширения, а программы на языке Python с графическим интерфейсом, в частности в Windows и Mac OS X, обычно имеют расширение .pyw.

## Как писать программы
### Интерактивный режим
В основном интерпретатор выполняет команды построчно: пишешь строку, нажимаешь Enter, интерпретатор выполняет ее, наблюдаешь результат.

Работать в интерактивном режиме в ОС Linux можно в консоли. Для этого следует выполнить команду python. Запустится интерпретатор, где сначала выведется информация об интерпретаторе. Далее, последует приглашение к вводу (>>>).

### Запустите интерпретатор Питона.

    2 + 5
    3 * (5 - 8)
    2.4 + 3.0 / 2
    и т.д.

Наберите подобные примеры в интерактивном режиме (в конце каждого нажимайте Enter).

Ответ выдается сразу после нажатия Enter (завершения ввода команды).
Бывает, что в процессе ввода была допущена ошибка или требуется повторить ранее используемую команду. Чтобы не писать строку сначала, в консоли можно прокручивать список команд, используя для этого стрелки на клавиатуре.

Другой вариант работы в интерактивном режиме — это работа в среде разработки IDLE, у которой есть интерактивный режим работы.

### IDLE (Integrated DeveLopment Environment)
— это интегрированная среда разработки на языке Python, созданная с помощью библиотеки Tkinter. Поставляется вместе с Python и благодаря использованию Tkinter может использоваться на многих платформах, среди которых Windows, Mac OS, Unix-подобные python.org/idle — официальный сайт IDLE

Среда IDLE обеспечивает ключевые возможности:

- ввод выражений и программного кода на языке Python с получением результатов прямо в командной оболочке Python;
- предоставляет редактор программного кода с подсветкой синтаксиса языка Python и поддержкой функции оформления отступов и отладчик, который может использоваться в режиме пошагового выполнения программного кода, облегчая поиск и устранение ошибок.

Использование IDLE
------------------
Первое, что стоит сделать это определить свое рабочее место, то есть создать папку, в которой вы будете работать и экспериментировать. Второе,— это запустить интерактивную оболочку языка — IDLE.

После того как вы установили на свой компьютер Python, вы можете запустить IDLE в Windows, пройдя по следующему пути: Пуск → Все программы → Python 2.7 → IDLE (Python GUI). На экране появляется окно с заголовком Python Shell.

В меню File выберите пункт New Window. Появится окно, в котором мы запишем нашу однострочную программу:

    print ('Hello World!')

Теперь ваша программа находится в редакторе IDLE, но перед тем как программу запустить, ее нужно сохранить. Выберите File, затем Save As и найдите в обозревателе папку, которую вы создали для программ. Введите название программы - hello.py.

Как запустить программу
-----------------------
Для того, чтобы запустить программу, выбираем Run → Run Module или нажимаем F5. В окне IDLE мы увидим результат

Командная оболочка Python
-------------------------
особенно удобна при опробовании простых алгоритмов, фрагментов программного кода и регулярных выражений и может использоваться как очень мощный и гибкий калькулятор.

## Print - функция
Оператор print был заменён функцией print(), с именованными аргументами для замены большей части синтаксиса старого оператора print.

### Примеры:

    Python2: print "The answer is", 2*2
    Python3: print("The answer is", 2*2)
    Python2: print x,    # Запятая в конце подавляет перевод строки
    Python3: print(x, end=" ")  # Добавляет пробел вместо перевода строки
    Python2: print              # Печатает перевод строки
    Python3: print()            # Нужно вызвать функцию!
    Python2: print >>sys.stderr, "fatal error"
    Python3: print("fatal error", file=sys.stderr)
    Python2: print (x, y)       # Печатает repr((x, y))
    Python3: print((x, y))      # Не путать с print(x, y)!

Также вы можете настроить разделитель между элементами, например:

    >>> print("There are <", 2**32, "> possibilities!", sep="")
    There are <4294967296> possibilities!

### Синтаксис
Конец строки является концом инструкции (точка с запятой не требуется).
Вложенные инструкции объединяются в блоки по величине отступов. Отступ может быть любым, главное, чтобы в пределах одного вложенного блока отступ был одинаков.

Используйте 4 пробела.
----------------------
Вложенные инструкции в Python записываются в соответствии с одним и тем же шаблоном, когда основная инструкция завершается двоеточием, вслед за которым располагается вложенный блок кода, обычно с отступом под строкой основной инструкции.

## Создание скриптов
### Кодировка исходного файла

- Кодировка Python должна быть UTF-8 (ASCII в Python 2).
- Файлы в ASCII (Python 2) или UTF-8 (Python 3) не должны иметь объявления кодировки.

В стандартной библиотеке, нестандартные кодировки должны использоваться только для целей тестирования, либо когда комментарий или строка документации требует упомянуть имя автора, содержащего не ASCII символы; в остальных случаях использование \x, \u, \U или \N - наиболее предпочтительный способ включить не ASCII символы в строковых литералах.

Начиная с версии python 3.0 в стандартной библиотеке действует следующее соглашение:
- все идентификаторы обязаны содержать только ASCII символы, и означать английские слова везде, где это возможно (во многих случаях используются сокращения или неанглийские технические термины).
- строки и комментарии тоже должны содержать лишь ASCII символы. Исключения составляют: (а) test case, тестирующий не-ASCII особенности программы, и (б) имена авторов.
- Авторы, чьи имена основаны не на латинском алфавите, должны транслитерировать свои имена в латиницу.

### Кодировки (PEP 263)
Код ядра python всегда должен использовать ASCII или Latin-1 кодировку (также известную как ISO-8859-1). Начиная с версии python 3.0, предпочтительной является кодировка UTF-8 (PEP 3120).

### Unicode Strings

    >>>
    >>> u'Hello World !'
    u'Hello World !'

Python Unicode-Escape encoding.  escape sequence \u0020

    >>>
    >>> u'Hello\u0020World !'
    u'Hello World !'
    >>>

    >>> ur'Hello\u0020World !'
    u'Hello World !'

    >>> ur'Hello\\u0020World !'
    u'Hello\\\\u0020World !'
    >>>

    >>> u"abc"
    u'abc'

    >>> str(u"abc")
    'abc'

    >>> u"äöü"
    u'\xe4\xf6\xfc'

    >>> str(u"äöü")
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-2: ordinal not in range(128)
    >>>

    >>> u"äöü".encode('utf-8')
    '\xc3\xa4\xc3\xb6\xc3\xbc'
    unicode() function
    >>>

    >>> unicode('\xc3\xa4\xc3\xb6\xc3\xbc', 'utf-8')
    u'\xe4\xf6\xfc'

    >>> u'Слово'
    u'\u0421\u043b\u043e\u0432\u043e'

    >>> u'Слово'.encode('utf8')
    '\xd0\xa1\xd0\xbb\xd0\xbe\xd0\xb2\xd0\xbe'

    >>> u'\xd0\xa1\xd0\xbb\xd0\xbe\xd0\xb2\xd0\xbe'
    u'\xd0\xa1\xd0\xbb\xd0\xbe\xd0\xb2\xd0\xbe'

    >>> u'\u0421\u043b\u043e\u0432\u043e'
    u'\u0421\u043b\u043e\u0432\u043e'

    >>> print u'\u0421\u043b\u043e\u0432\u043e'
    Слово

    >>> print u'Слово'
    Слово

    >>> print 'Слово'
    Слово

### Source Code Encoding

    # -*- coding: encoding -*-
    # -*- coding: cp-1252 -*-

## Комментарии
Комментарии, которые противоречат коду, хуже, чем отсутствие комментариев. Всегда исправляйте комментарии, если меняете код!
Комментарии должны являться законченными предложениями. Если комментарий — фраза или предложение, первое слово должно быть написано с большой буквы, если только это не имя переменной, которая начинается с маленькой буквы (кстати, никогда не отступайте от этого правила для имен переменных).

Если комментарий короткий, можно опустить точку в конце предложения. Блок комментариев обычно состоит из одного или более абзацев, составленных из полноценных предложений, поэтому каждое предложение должно оканчиваться точкой.

Ставьте два пробела после точки в конце предложения.

Если вы пишете по-английски, не забывайте о Странке и Уайте (книга Strunk & White, “Elements of style”, которая является практически эталонным руководством по правильному написанию текстов на английском языке.)

Программисты, которые не говорят на английском языке, пожалуйста, пишите комментарии на английском, если только вы не уверены на 120 процентов, что ваш код никогда не будут читать люди, не знающие вашего родного языка.

### Блок комментариев
Блок комментариев обычно объясняет код (весь, или только некоторую часть), идущий после блока, и должен иметь тот же отступ, что и сам код. Каждая строчка такого блока должна начинаться с символа # и одного пробела после него (если только сам текст комментария не имеет отступа).

Абзацы внутри блока комментариев лучше отделять строкой, состоящей из одного символа #.

### Комментарии в строке с кодом
Старайтесь реже использовать подобные комментарии.

Такой комментарий находится в той же строке, что и инструкция. «Встрочные» комментарии должны отделяться хотя бы двумя пробелами от инструкции. Они должны начинаться с символа # и одного пробела.

Комментарии в строке с кодом не нужны и только отвлекают от чтения, если они объясняют очевидное. Не пишите вот так:

    x = x + 1                 # Увеличиваем X на один

Впрочем, иногда такие комметарии полезны:

    x = x + 1                  # Место для рамки окна

# Строки документации
Соглашения о написании хорошей документации (docstrings) увековечены в PEP 257.

Пишите документацию для всех модулей, функций, классов, методов, которые объявлены как public. Строки документации необязательны для не-public методов, но лучше написать, что делает метод. Комментарий нужно писать после строки с def.

PEP 257 объясняет, как правильно и хорошо документировать. Заметьте, очень важно, чтобы закрывающие """ стояли на отдельной строчке. А еще лучше, если перед ними будет ещё и пустая строка, например:

        """Return a foobang
        Optional plotz says to frobnicate the bizbaz first.

        """

Для однострочной документации можно оставить """ на той же строке.

# Основная инструкция:
## Вложенный блок инструкций
### Несколько специальных случаев

Иногда возможно записать несколько инструкций в одной строке, разделяя их точкой с запятой:

    a = 1; b = 2; print(a, b)

Допустимо записывать одну инструкцию в нескольких строках. Достаточно ее заключить в пару круглых, квадратных или фигурных скобок:

    if (a == 1 and b == 2 and
        c == 3 and d == 4):  # Не забываем про двоеточие
          print('spam' * 3)

Тело составной инструкции может располагаться в той же строке, что и тело основной, если тело составной инструкции не содержит составных инструкций. пример:

    if x > y: print(x)

## Идентификаторы и ключевые слова
Создавая элемент данных, мы можем либо присвоить его переменной, либо вставить в коллекцию. (когда в языке Python выполняется операция присваивания, в действительности происходит связывание ссылки на объект с объектом в памяти, который хранит данные.)

Имена, которые даются ссылкам на объекты, называются идентификаторами, или просто именами. Допустимый идентификатор в языке Python - это последовательность символов произвольной длины, содержащей «начальный символ» и ноль или более «символов продолжения». Такой идентификатор  должен следовать определенным правилам и соглашениям.

- Первое правило касается начального символа и символов продолжения.

Начальным символом может быть любой символ, который в кодировке Юникод рассматривается как принадлежащий диапазону алфавитных символов ASCII («а», «Ь», ..., «z», «А», «В», ..., «Z»), символ подчеркивания («__»), а также символы большинства национальных (не английских) алфавитов. Каждый символ продолжения может быть любым символом из тех, что пригодны в качестве начального символа, а также любым непробельным символом, включая символы, которые в кодировке Юникод считаются цифрами, такие как («О», «1», ..., «9»), и символ Каталана «•». Идентификаторы чувствительны к регистру, поэтому TAXRATE, Tax rate, TaxRate, taxRate и tax rate - это пять разных идентификаторов.

Точный перечень символов, допустимых для использования в качестве начального символа и символов продолжения, описывается в документации по языку Python (справочник «Language reference», раздел «Lexical analysis», подраздел «Identifiers and keywords»1) или в PEP 31312 (раздел «Supporting Non-ASCII Identifiers»).

- Второе правило гласит
Не использовать в качестве своих идентификаторов любые предопределенные имена.

Как определить, относится ли тот или иной идентификатор к этим категориям? В языке Python имеется встроенная функция dir(), которая возвращает список атрибутов объекта. Если эта функция вызывается без аргументов, она возвращает список встроенных атрибутов языка Python.

    dir()  ['__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__']

Атрибут builtins в действительности является модулем, в котором определены все встроенные атрибуты языка Python. Его можно использовать в качестве аргумента функции diг ():

    dir(builtins)

В списке присутствует более 130 имен. Имена, начинающиеся с символов верхнего регистра, являются именами встроенных исключений. Остальные имена представляют функции и типы данных.

PyLint (www.logilab.org/project/name/pylint). Этот инструмент поможет вам также выявлять множество других фактических или потенциальных проблем в программах на языке Python.

### соглашение касается использования символа подчеркивания (_).
Не должны использоваться имена, начинающиеся и заканчивающиеся двумя символами подчеркивания.

Символ подчеркивания сам по себе может использоваться в качестве идентификатора внутри интерактивной оболочки интерпретатора или в командной оболочке Python в переменной с именем _ сохраняется результат последнего вычисленного выражения. Во время выполнения обычной программы идентификатор _ отсутствует, если мы явно не определяем его в своем программном коде. Некоторые программисты любят использовать _ в качестве идентификатора переменной цикла в циклах for ... in, когда не требуется обращаться к элементам, по которым выполняются итерации. Например:

    for _ in (0, 1, 2, 3, 4, 5):
        print("Hello")

Но имейте в виду, что те, кто пишет программы, которые затем интернационализируются, часто используют идентификатор _ в качестве имени функции перевода.

Делается это, чтобы вместо необходимости писать всякий раз gettext.gettext("Translate me") можно было писать _("Translate me"). (Чтобы можно было выполнить такой вызов, мы сначала должны импортировать модуль gettext, чтобы получить доступ к функции gettext (), находящейся в этом модуле).

Самый простой способ проверить допустимость идентификатора состоит в том, чтобы попробовать присвоить ему некоторое значение в интерактивной оболочке интерпретатора Python или в командной оболочке Python среды IDLE.

    stretch-factor = 1
    SyntaxError: can't assign to operator (...)
    (SyntaxError: невозможно выполнить присваивание оператору (...))

    2miles = 2
    SyntaxError: invalid syntax (...)

Попытка использовать недопустимый идентификатор вызывает исключение SyntaxError.

# Соглашения по именованию
Соглашения по именованию переменных в python немного туманны, поэтому их список никогда не будет полным — тем не менее, ниже мы приводим список рекомендаций, действующих на данный момент. Новые модули и пакеты должны быть написаны согласно этим стандартам, но если в какой-либо уже существующей библиотеке эти правила нарушаются, предпочтительнее писать в едином с ней стиле.

## Главный принцип

Имена, которые видны пользователю как часть общественного API должны следовать конвенциям, которые отражают использование, а не реализацию.

### Описание: Стили имен

Обычно различают следующие стили:

- b (одиночная маленькая буква)
- B (одиночная заглавная буква)
- lowercase (слово в нижнем регистре)
- lower_case_with_underscores (слова из маленьких букв с подчеркиваниями)
- UPPERCASE (заглавные буквы)
- UPPERCASE_WITH_UNDERSCORES (слова из заглавных букв с подчеркиваниями)
- CapitalizedWords (слова с заглавными буквами, или CapWords, или CamelCase), когда вы используете аббревиатуры в таком стиле, пишите все буквы аббревиатуры заглавными — HTTPServerError лучше, чем HttpServerError.
- mixedCase (отличается от CapitalizedWords тем, что первое слово начинается с маленькой буквы)
- Capitalized_Words_With_Underscores (слова с заглавными буквами и подчеркиваниями)

Ещё существует стиль, в котором имена, принадлежащие одной логической группе, имеют один короткий префикс. Этот стиль редко используется в python. Например, функция os.stat() возвращает кортеж, имена в котором традиционно имеют вид st_mode, st_size, st_mtime и так далее. (Так сделано, чтобы подчеркнуть соответствие этих полей структуре системных вызовов POSIX, что помогает знакомым с ней программистам).

В библиотеке X11 используется префикс Х для всех public-функций. В python этот стиль считается излишним, потому что перед полями и именами методов стоит имя объекта, а перед именами функций стоит имя модуля.

В дополнение к этому, используются следующие специальные формы записи имен с добавлением символа подчеркивания в начало или конец имени:

_single_leading_underscore: слабый индикатор того, что имя используется для внутренних нужд. Например, from M import * не будет импортировать объекты, чьи имена начинаются с символа подчеркивания.

single_trailing_underscore_: используется по соглашению для избежания конфликтов с ключевыми словами языка python, например:

    Tkinter.Toplevel(master, class_='ClassName')

__double_leading_underscore: изменяет имя атрибута класса, то есть в классе FooBar поле __boo становится _FooBar__boo.

__double_leading_and_trailing_underscore__ (двойное подчеркивание в начале и в конце имени): магические методы или атрибуты, которые находятся в пространствах имен, управляемых пользователем. Например, __init__, __import__ или __file__. Не изобретайте такие имена, используйте их только так, как написано в документации.

### Предписания: соглашения по именованию

### Имена, которых следует избегать
Никогда не используйте символы l (маленькая латинская буква «эль»), O (заглавная латинская буква «о») или I (заглавная латинская буква «ай») как однобуквенные идентификаторы.

В некоторых шрифтах эти символы неотличимы от цифры один и нуля. Если очень нужно l, пишите вместо неё заглавную L.

## Внешний вид кода
### Отступы

Используйте 4 пробела на каждый уровень отступа.

Продолжительные строки должны выравнивать обернутые элементы либо вертикально, используя неявную линию в скобках (круглых, квадратных или фигурных), либо с использованием висячего отступа. При использовании висячего отступа следует применять следующие соображения: на первой линии не должно быть аргументов, а остальные строки должны четко восприниматься как продолжение линии.

    # Выровнено по открывающему разделителю
    foo = long_function_name(var_one, var_two,
                             var_three, var_four)

    # Больше отступов включено для отличения его от остальных
    def long_function_name(
            var_one, var_two, var_three,
            var_four):
        print(var_one)
    # Нет необходимости в большем количестве отступов.
    foo = long_function_name(
      var_one, var_two,
      var_three, var_four)

Закрывающие круглые/квадратные/фигурные скобки в многострочных конструкциях могут находиться под первым непробельным символом последней строки списка, например:

    my_list = [
        1, 2, 3,
        4, 5, 6,
        ]
    result = some_function_that_takes_arguments(
        'a', 'b', 'c',
        'd', 'e', 'f',
        )

либо быть под первым символом строки, начинающей многострочную конструкцию:

    my_list = [
        1, 2, 3,
        4, 5, 6,
    ]
    result = some_function_that_takes_arguments(
        'a', 'b', 'c',
        'd', 'e', 'f',
    )

## Табуляция или пробелы?

Пробелы - самый предпочтительный метод отступов.

Табуляция должна использоваться только для поддержки кода, написанного с отступами с помощью табуляции.

Python 3 запрещает смешивание табуляции и пробелов в отступах.
--------------------------------------------------------------
Python 2 пытается преобразовать табуляцию в пробелы.
----------------------------------------------------
Когда вы вызываете интерпретатор Python 2 в командной строке с параметром -t, он выдает предупреждения (warnings) при использовании смешанного стиля в отступах, а запустив интерпретатор с параметром -tt, вы получите в этих местах ошибки (errors). Эти параметры очень рекомендуются!
### Максимальная длина строки

Ограничьте длину строки максимум 79 символами.

Для более длинных блоков текста с меньшими структурными ограничениями (строки документации или комментарии), длину строки следует ограничить 72 символами.

Ограничение необходимой ширины окна редактора позволяет иметь несколько открытых файлов бок о бок, и хорошо работает при использовании инструментов анализа кода, которые предоставляют две версии в соседних столбцах.

Некоторые команды предпочитают большую длину строки. Для кода, поддерживающегося исключительно или преимущественно этой группой, в которой могут прийти к согласию по этому вопросу, нормально увеличение длины строки с 80 до 100 символов (фактически увеличивая максимальную длину до 99 символов), при условии, что комментарии и строки документации все еще будут 72 символа.

Стандартная библиотека Python консервативна и требует ограничения длины строки в 79 символов (а строк документации/комментариев в 72).

Предпочтительный способ переноса длинных строк является использование подразумеваемых продолжений строк Python внутри круглых, квадратных и фигурных скобок. Длинные строки могут быть разбиты на несколько строк, обернутые в скобки. Это предпочтительнее использования обратной косой черты для продолжения строки.

Обратная косая черта все еще может быть использована время от времени. Например, длинная конструкция with не может использовать неявные продолжения, так что обратная косая черта является приемлемой:

    with open('/path/to/some/file/you/want/to/read') as file_1, \
            open('/path/to/some/file/being/written', 'w') as file_2:
        file_2.write(file_1.read())

## Пустые строки

Отделяйте функции верхнего уровня и определения классов двумя пустыми строками.

Определения методов внутри класса разделяются одной пустой строкой.

Дополнительные пустые строки возможно использовать для разделения различных групп похожих функций. Пустые строки могут быть опущены между несколькими связанными однострочниками (например, набор фиктивных реализаций).

Используйте пустые строки в функциях, чтобы указать логические разделы.

Python расценивает символ control+L как незначащий (whitespace), и вы можете использовать его, потому что многие редакторы обрабатывают его как разрыв страницы — таким образом логические части в файле будут на разных страницах. Однако, не все редакторы распознают control+L и могут на его месте отображать другой символ.

## Импорты

Каждый импорт, как правило, должен быть на отдельной строке.

    import os
    import sys

В то же время, можно писать так:

    from subprocess import Popen, PIPE


Импорты всегда помещаются в начале файла, сразу после комментариев к модулю и строк документации, и перед объявлением констант.

Импорты должны быть сгруппированы в следующем порядке:

- импорты из стандартной библиотеки
- импорты сторонних библиотек
- импорты модулей текущего проекта

Вставляйте пустую строку между каждой группой импортов.

Указывайте спецификации __all__ после импортов.

Рекомендуется абсолютное импортирование, так как оно обычно более читаемо и ведет себя лучше если импортируемая система настроена неправильно (например, когда каталог внутри пакета заканчивается на sys.path):

    import mypkg.sibling
    from mypkg import sibling
    from mypkg.sibling import example

Тем не менее, явный относительный импорт является приемлемой альтернативой абсолютному импорту, особенно при работе со сложными пакетами, где использование абсолютного импорта было бы излишне подробным:

    from . import sibling
    from .sibling import example

В стандартной библиотеке следует избегать сложной структуры пакетов и всегда использовать абсолютные импорты.

Неявные относительно импорты никогда не должны быть использованы, и были удалены в Python 3.

### Пробелы в выражениях и инструкциях
Избегайте использования пробелов в следующих ситуациях:

Непосредственно внутри круглых, квадратных или фигурных скобок.

    spam(ham[1], {eggs: 2})

Непосредственно перед запятой, точкой с запятой или двоеточием:

    if x == 4: print(x, y); x, y = y, x

Сразу перед открывающей скобкой, после которой начинается список аргументов при вызове функции:

    spam(1)

Сразу перед открывающей скобкой, после которой следует индекс или срез:

    dict['key'] = list[index]

Использование более одного пробела вокруг оператора присваивания (или любого другого) для того, чтобы выровнять его с другим:

    x = 1
    y = 2
    long_variable = 3

### Другие рекомендации

Всегда окружайте эти бинарные операторы одним пробелом с каждой стороны: присваивания (=, +=, -= и другие), сравнения (==, <, >, !=, <>, <=, >=, in, not in, is, is not), логические (and, or, not).

Если используются операторы с разными приоритетами, попробуйте добавить пробелы вокруг операторов с самым низким приоритетом. Используйте свои собственные суждения, однако, никогда не используйте более одного пробела, и всегда используйте одинаковое количество пробелов по обе стороны бинарного оператора.

    i = i + 1
    submitted += 1
    x = x*2 - 1
    hypot2 = x*x + y*y
    c = (a+b) * (a-b)

Не используйте пробелы вокруг знака =, если он используется для обозначения именованного аргумента или значения параметров по умолчанию.

    def complex(real, imag=0.0):
        return magic(r=real, i=imag)

Не используйте составные инструкции (несколько команд в одной строке).

    if foo == 'blah':
        do_blah_thing()
    do_one()
    do_two()
    do_three()

Иногда можно писать тело циклов while, for или ветку if в той же строке, если команда короткая, но если команд несколько, никогда так не пишите. А также избегайте длинных строк!

## Советы по программированию на Python

### PyChecker

Используйте PyChecker для проверки своего кода

PyChecker — это инструмент для нахождения багов в исходниках Python-программ. Он находит проблемы, которые были бы выявлены компилятором менее динамичных языков, таких как С и С++. В силу динамической природы языка Python, некоторые предупреждения могут быть несправедливыми, однако ложные предупреждения не должны встречаться часто.

Отлавливает трудновыявляемые ошибки, такие как: ошибки типов, использование переменных перед их объявлением и т.д.

PyChecker не идеален. Чтобы получить все его преимущества нам нужно:
- Писать с оглядкой на него
- Подавить его предупреждения
- Исправлять ошибки
- Либо не обращать внимания на них внимания

Убедитесь, что Вы запустили PyChecker с вашим кодом. Для того чтобы узнать как запустить PyChecker, загляните на его домашнюю страницу. Чтобы подавить предупреждения, вам нужно создать переменную __pychecker__ в данном модуле и указать какие ошибки должны подавляться. Например:

    __pychecker__ = 'no-callinit no-classattr'

Подавление предупреждений таким путем имеет преимущество следующего плана — мы можем с легкостью производить поиск по подавлениям и возвращаться к ним. Вы можете познакомиться со списком предупреждений PyChecker, если наберете:

    pychecker -- help

Неиспользуемые аргументы могут быть опущены при помощи '_', как наименования неиспользуемого аргумента, либо префикса аргумента «unused_». В ситуациях когда изменение имени аргумента невозможно, Вы можете упомянуть их в начале функции. Например:

    def foo(a, unused_b, unused_c, d=None, e=None):
        _ = d, e
        return a

# Глобальные переменные

Избегайте использования глобальных переменных

Переменные, которые определены на уровне модуля.

Иногда полезны.

Можно нечаянно изменить поведение модуля при импорте, т.к. присваивание переменных уровня модуля уже завершено когда модуль импортируется.

Избегайте использования глобальных переменных в пользу переменных класса.

### Несколько исключений ниже:
### Стандартные настройки скриптов.
Константы уровня модуля. Например, PI = 3.14159. Константы должны быть именованы с использованием только заглавных букв и символа подчеркивания.

Иногда полезно использовать глобальные переменные, чтобы кэшировать значения, необходимые для функции или возвращаемые функцией.

# Модуль keyword

keyword.kwlist - список всех доступных ключевых слов.
keyword.iskeyword(строка) - является ли строка ключевым словом.

## Ключевые слова

- False - ложь.
- True - правда.
- None - "пустой" объект.
- and - логическое И.
- with / as - менеджер контекста.
- assert условие - возбуждает исключение, если условие ложно.
- break - выход из цикла.
- class - пользовательский тип, состоящий из методов и атрибутов.
- continue - переход на следующую итерацию цикла.
- def - определение функции.
- del - удаление объекта.
- elif - в противном случае, если.
- else - см. for/else или if/else.
- except - перехватить исключение.
- finally - вкупе с инструкцией try, выполняет инструкции независимо от того, было ли исключение или нет.
- for - цикл for.
- from - импорт нескольких функций из модуля.
- global - позволяет сделать значение переменной, присвоенное ей внутри функции, доступным и за пределами этой функции.
- if - если.
- import - импорт модуля.
- in - проверка на вхождение.
- is - ссылаются ли 2 объекта на одно и то же место в памяти.
- lambda - определение анонимной функции.
- nonlocal - позволяет сделать значение переменной, присвоенное ей внутри функции, доступным в объемлющей инструкции.
- not - логическое НЕ.
- or - логическое ИЛИ.
- pass - ничего не делающая конструкция.
- raise - возбудить исключение.
- return - вернуть результат.
- try - выполнить инструкции, перехватывая исключения.
- while - цикл while.
- yield - определение функции-генератора.

Первая программа
============
Компьютерная программа — это всего лишь набор инструкций для компьютера, написанных на компьютерном языке. Большинство компьютерных языков выглядят похожими на английский, но они гораздо проще. Число зарезервированных слов и устойчивых выражений сильно ограничено, поэтому чтобы совершить какую-то операцию, мы должны комбинировать эти слова и выражения. Текст программы, содержащий эти инструкции, расположен в одном или более файлах. Компьютер делает только то, что программа говорит ему делать.

Другое значение слова "программа" — это файл, который запускается для выполнения какой-то задачи. Иногда это файл с инструкциями, а иногда это "перевод" инструкций на языке программирования в более понятный и потому более эффективный компьютерный язык, который сложно понять человеку.

Программирование это написание программ, но этот процесс — не просто задание правильных инструкций, записанных в файле. Во-первых, мы должны понять, как проблема может быть решена заданием инструкций компьютеру. Это обычно наиболее сложная вещь в программировании. Во-вторых, мы должны правильно перевести наши инструкции в язык программирования и записать соответствующий текст в файл. В-третьих, мы должны запустить программу, проверить правильность результатов, и тут обычно наступает "в-четвертых" — найти и исправить ошибки. Овладение всем этим процессом требует долгой тренировки, которая заключается в написании большого числа работающих программ.

# Simple Interpreter

if you don’t know how compilers and interpreters work, then you don’t know how computers work. It’s that simple.

- Programming involves listing all the things that must happen to solve a problem
- When writing a program first determine step-by-step what needs to happen
- Then convert those steps into the language being Python in this situation

# The ability to output information to the screen, files, etc.
## helloCalc.py
        # -*- coding:utf-8 -*-
        # ---------- Hello Calc ----------
        # Single line comments are ignored by the interpreter
        '''
        So are multiline comments
        '''

        # print('Hello Super Calc')
        print 'Hello Super Calc'

# The ability to make mathematical calculations
## Программа как калькулятор

## firstCalc.py

        # -*- coding:utf-8 -*-
        # ---------- Hello Calc ----------
        # Single line comments are ignored by the interpreter
        '''
        Четыре стандартных арифметических операции в Python, как во многих других языках программирования записываются так +, -, * и /. Возведение в степень записывается двумя звездочками: **.

        '''
        # print('Hello Super Calc')
        print 'Hello Super Calc'
        print 2 + 2
        print 2 - 2
        print 2 * 2
        print 2 / 2
        print 2 % 2

#  The ability to change data
# Переменные, имена и объекты

В Python все — булевы значения, целые числа, числа с плавающей точкой, строки и даже крупные структуры данных, функции и программы — реализовано как объект. Это позволяет языку быть стабильным (и дает полезные особенности), чего не хватает некоторым другим языкам.

## Переменные

Конечно, простая подстановка чисел не очень интересная задача. Большинство языков программирования, в том числе и Python используют переменные также как это делается в математике.

## varCalc.py

        # -*- coding:utf-8 -*-
        # ---------- Hello Calc ----------
        # Single line comments are ignored by the interpreter
        '''
        В Python все — булевы значения, целые числа, числа с плавающей точкой, строки и даже крупные структуры данных, функции и программы — реализовано как объект.
        '''
        x = 2
        y = 2
        print 'Hello Super Calc'
        print x + y
        print x - y
        print x * y
        print x / y
        print x % y
        '''
        В Python, если вы хотите узнать тип какого-то объекта (переменной или значения), вам следует использовать конструкцию type(объект) .
        '''
        print type(x)


# Числа
Python имеет встроенную поддержку целых чисел (5 и 1 000 000 000) и чисел с плавающей точкой (3,1416, 14,99 и 1,87е4). Вы можете вычислять комбинации чисел с помощью простых математических операторов

-        + Сложение
-        – Вычитание
-        * Умножение
-        / Деление с плавающей точкой
-        // Целочисленное (Truncating) деление
-        % Modulus (вычисление остатка)
-        ** Возведение в степень

# Целые числа
- Любая последовательность цифр в Python считается целым числом
- Можно использовать и простой ноль ( 0 ). Но не ставьте его перед другими цифрами
- Последовательность цифр указывает на целое число. Если вы поместите знак + перед цифрами, число останется прежним
- Чтобы указать на отрицательное число, вставьте перед цифрами знак -
- Вы можете работать с любым количеством чисел и операторов
    >>> 5 + 9 + 3
    17
    >>> 4 + 3 — 2 — 1 + 6
    10

В Python выражение, стоящее справа от знака = , вычисляется первым и только затем присваивается переменной с левой стороны.

1.	 Вычитаем 3 из а .
2.	 Присваиваем результат этого вычитания временной переменной.
3.	 Присваиваем значение временной переменной а :

    >>> a = 95
    >>> temp = a — 3
    >>> a = temp

    Поэтому, когда вы говорите:
    >>> a = a — 3

Python рассчитывает результат операции вычитания с правой стороны от знака  =,  запоминает результат, а затем присваивает его переменной а , которая находится с левой стороны.
Вы можете совместить арифметические операторы с  присваиванием, размещая оператор перед знаком = . В этом примере выражение а -= 3 аналогично выражению  а = а – 3 :

    >>> a = 95
    >>> a -= 3
    >>> a

# Приоритет операций
Рассмотрим, что получится, если ввести следующее:
    >>> 2 + 3 * 4
Если выполнить сложение первым, 2 + 3 равно 5 , а  5 * 4 равно 20 . Но если выполнить первым умножение, 3 * 4 равно 12 , а  2 + 12 равно 14 . В Python, как и в большинстве других языков, умножение имеет больший приоритет, нежели сложение, поэтому вы увидите ответ, совпадающий со второй версией:
    >>> 2 + 3 * 4
    14
Как узнать приоритет той или иной операции? Гораздо проще добавить пару скобок, чтобы сгруппировать код и вычисления так, как нужно:
    >>> 2 + (3 * 4)
    14

# The ability to accept input and store it in many ways
## input1Calc.py

        # -*- coding:utf-8 -*-
        # ---------- MATH ON 2 VALUES ----------
        '''
        To run under Python3 replace 'raw_input' call
        with 'input'
        '''
        print 'Hello Super Calc'
        x = raw_input("Enter x: ")
        y = raw_input("Enter y: ")

        # Add the values entered and store in sum
        sum = x + y

        # Subtract the values and store in difference
        difference = x - y

        # Multiply the values and store in product
        product = x * y

        # Divide the values and store in quotient
        quotient = x / y

        # Use modulus on the values to find the remainder
        remainder = x % y

        print sum
        print difference
        print product
        print quotient
        print remainder

# Преобразования типов
Для того чтобы изменить другие типы данных на целочисленный тип, следует ис   пользовать функцию int() . Она сохраняет целую часть числа и отбрасывает любой остаток.
Простейший тип данных в Python — булевы переменные, значениями этого типа     могут быть только True или False. При преобразовании в целые числа они представляют собой значения 1 и 0:

        >>> int(True)
        1
        >>> int(False)
        0

## inputCalc.py

        # -*- coding:utf-8 -*-
        # ---------- MATH ON 2 VALUES ----------
        '''
        To run under Python3 replace 'raw_input' call
        with 'input'
        '''
        print 'Hello Super Calc'
        x = int(raw_input("Enter x: "))
        y = int(raw_input("Enter y: "))

        # Add the values entered and store in sum
        sum = x + y

        # Subtract the values and store in difference
        difference = x - y

        # Multiply the values and store in product
        product = x * y

        # Divide the values and store in quotient
        quotient = x / y

        # Use modulus on the values to find the remainder
        remainder = x % y

        print sum
        print difference
        print product
        print quotient
        print remainder

# Print your results
# format() loads the variable values in order into the {} placeholders
## printCalc.py
            # -*- coding:utf-8 -*-
            # ---------- MATH ON 2 VALUES ----------
            '''
            To run under Python3 replace 'raw_input' call
            with 'input'
            '''
            print 'Hello Super Calc'
            x = int(raw_input("Enter x: "))
            y = int(raw_input("Enter y: "))

            # Add the values entered and store in sum
            sum = x + y

            # Subtract the values and store in difference
            difference = x - y

            # Multiply the values and store in product
            product = x * y

            # Divide the values and store in quotient
            quotient = x / y

            # Use modulus on the values to find the remainder
            remainder = x % y

            # Print your results
            # format() loads the variable values in order into the {} placeholders
            print ("{} + {} = {}".format(x, y, sum))
            print ("{} - {} = {}".format(x, y, difference))
            print ("{} * {} = {}".format(x, y, product))
            print ("{} / {} = {}".format(x, y, quotient))
            print ("{} % {} = {}".format(x, y, remainder))


# The ability to conditionally do one thing or another thing
## operatorCalc.py
            # -*- coding:utf-8 -*-
            # ---------- CALCULATOR ----------
            '''
            To run under Python3 replace 'raw_input' call
            with 'input'
            Store the user input an operator
            '''
            print 'Super Calc'

            # Convert strings into integers
            x = int(raw_input("Enter x: "))
            y = int(raw_input("Enter y: "))

            # Store the user input an operator
            operator = raw_input('Enter Operator: ')

            # Add the values entered and store in sum
            sum = x + y

            # Subtract the values and store in difference
            difference = x - y

            # Multiply the values and store in product
            product = x * y

            # Divide the values and store in quotient
            quotient = x / y

            # Use modulus on the values to find the remainder
            remainder = x % y

            # If, else if (elif) and else execute different code depending on a condition
            if operator == "+":
                print ("{} + {} = {}".format(x, y, sum))

            # If the 1st condition wasn't true check if this one is
            elif operator == "-":
                print ("{} - {} = {}".format(x, y, difference))
            elif operator == "*":
                print ("{} * {} = {}".format(x, y, product))
            elif operator == "/":
                print ("{} / {} = {}".format(x, y, quotient))
            elif operator == "%":
                print ("{} % {} = {}".format(x, y, remainder))

            # If none of the above conditions were true then execute this by default
            else:
                print ("Use either + - * / or % next time")

            # Other conditional operators
            # > : Greater than
            # < : Less than
            # >= : Greater than or equal to
            # <= : Less than or equal to
            # != : Not equal to

# zerodivCalc.py

        # -*- coding:utf-8 -*-
        # ---------- CALCULATOR ----------
        '''
        To run under Python3 replace 'raw_input' call
        with 'input'
        Store the user input an operator
        '''
        print 'Super Calc'

        # Convert strings into integers
        x = int(raw_input("Enter x: "))
        y = int(raw_input("Enter y: "))

        # Store the user input an operator
        operator = raw_input('Enter Operator: ')

        # Add the values entered and store in sum
        sum = x + y

        # Subtract the values and store in difference
        difference = x - y

        # Multiply the values and store in product
        product = x * y

        # Divide the values and store in quotient
        # quotient = x / y

        # Use modulus on the values to find the remainder
        # remainder = x % y

        # If, else if (elif) and else execute different code depending on a condition
        if operator == "+":
            print ("{} + {} = {}".format(x, y, sum))

        # If the 1st condition wasn't true check if this one is
        elif operator == "-":
            print ("{} - {} = {}".format(x, y, difference))
        elif operator == "*":
            print ("{} * {} = {}".format(x, y, product))
        elif operator == "/":
            if y==0:
                print 'integer division or modulo by zero'
            else:
                print ("{} / {} = {}".format(x, y, x / y))
        elif operator == "%":
            print ("{} % {} = {}".format(x, y, x % y))

        # If none of the above conditions were true then execute this by default
        else:
            print ("Use either + - * / or % next time")

        # Other conditional operators
        # > : Greater than
        # < : Less than
        # >= : Greater than or equal to
        # <= : Less than or equal to
        # != : Not equal to

Преобразование числа с плавающей точкой в целое число просто отсекает все,    что находится после десятичной запятой 1 :
                >>> int(98.6)
                98
                >>> int(1.0e4)
                10000
                1

Функция int() будет создавать целые числа из чисел с плавающей точкой или  строк, состоящих из цифр, но она не будет обрабатывать строки, содержащие десятичные точки или экспоненты:

# invalid literal for int() with base 10

# Числа с плавающей точкой
Значениями целочисленного типа являются целые числа, но числа с плавающей точкой (в Python они называются float) имеют десятичную запятую. Числа с плавающей точкой обрабатываются так же, как и целые: вы можете использовать операторы + , – , * , / , // , ** , % и функцию divmod() .

Для того чтобы преобразовать другие типы в тип float , следует использовать функцию float() . Как и ранее, булевы значения обрабатываются как небольшие числа:

## floatInputCalc.py

        # -*- coding:utf-8 -*-
        # ---------- CALCULATOR ----------
        '''
        To run under Python3 replace 'raw_input' call
        with 'input'
        Store the user input an operator
        '''
        print 'Super Calc'

        # Convert strings into integers
        x = float(raw_input("Enter x: "))
        y = float(raw_input("Enter y: "))

        # Store the user input an operator
        operator = raw_input('Enter Operator: ')

        # If, else if (elif) and else execute different code depending on a condition
        if operator == "+":
            print ("{} + {} = {}".format(x, y, x * y))

        # If the 1st condition wasn't true check if this one is
        elif operator == "-":
            print ("{} - {} = {}".format(x, y, x - y))
        elif operator == "*":
            print ("{} * {} = {}".format(x, y, x * y))
        elif operator == "/":
            if y==0:
                print 'integer division or modulo by zero'
            else:
                print ("{} / {} = {}".format(x, y, x / y))
        elif operator == "%":
            print ("{} % {} = {}".format(x, y, x % y))

        # If none of the above conditions were true then execute this by default
        else:
            print ("Use either + - * / or % next time")

# floatInputCalc3.py

        # -*- coding:utf-8 -*-
        # ---------- CALCULATOR ----------
        '''
        To run under Python2 replace 'input' call
        with 'raw_input'

        '''
        print('Super Calc')

        # Convert strings into integers
        x = float(input("Enter x: "))
        y = float(input("Enter y: "))

        # Store the user input an operator
        operator = input('Enter Operator: ')

        # If, else if (elif) and else execute different code depending on a condition
        if operator == "+":
            print ("{} + {} = {}".format(x, y, x * y))

        # If the 1st condition wasn't true check if this one is
        elif operator == "-":
            print ("{} - {} = {}".format(x, y, x - y))
        elif operator == "*":
            print ("{} * {} = {}".format(x, y, x * y))
        elif operator == "/":
            if y==0:
                print('integer division or modulo by zero')
            else:
                print ("{} / {} = {}".format(x, y, x / y))
        elif operator == "%":
            print ("{} % {} = {}".format(x, y, x % y))

        # If none of the above conditions were true then execute this by default
        else:
            print ("Use either + - * / or % next time")
