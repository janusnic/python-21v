# python-21v unit 02

# Операторы и выражения:

- + 	Сложение 	Суммирует два объекта 	3 + 5 даст 8; 'a' + 'b' даст 'ab'
- - 	Вычитание 	Даёт разность двух чисел; если первый операнд отсутствует, он считается равным нулю 	-5.2 даст отрицательное число, а 50 - 24 даст 26.
- * 	Умножение 	Даёт произведение двух чисел или возвращает строку, повторённую заданное число раз. 	2 * 3 даст 6. 'la' * 3 даст 'lalala'.
- ** 	Возведение в степень 	Возвращает число х, возведённое в степень y 	3 ** 4 даст 81 (т.е. 3 * 3 * 3 * 3)
- / 	Деление 	Возвращает частное от деления x на y 	4 / 3 даст 1.3333333333333333.
- // 	Целочисленное деление 	Возвращает неполное частное от деления 	4 // 3 даст 1.
- % 	Деление по модулю 	Возвращает остаток от деления 	8 % 3 даст 2. -25.5 % 2.25 даст 1.5.

- << 	Сдвиг влево 	Сдвигает биты числа влево на заданное количество позиций. (Любое число в памяти компьютера представлено в виде битов - или двоичных чисел, т.е. 0 и 1) 	2 << 2 даст 8. В двоичном виде 2 представляет собой 10. Сдвиг влево на 2 бита даёт 1000, что в десятичном виде означает 8.
- >> 	Сдвиг вправо 	Сдвигает биты числа вправо на заданное число позиций. 	11 >> 1 даст 5. В двоичном виде 11 представляется как 1011, что будучи смещённым на 1 бит вправо, даёт 101, а это, в свою очередь, ни что иное как десятичное 5
- & 	Побитовое И 	Побитовая операция И над числами 	5 & 3 даёт 1.
- | 	Побитовое ИЛИ 	Побитовая операция ИЛИ над числами 	5 | 3 даёт 7
- ^ 	Побитовое ИСКЛЮЧИТЕЛЬНО ИЛИ 	Побитовая операция ИСКЛЮЧИТЕЛЬНО ИЛИ 	5 ^ 3 даёт 6
- ~ 	Побитовое НЕ 	Побитовая операция НЕ для числа x соответствует -(x+1) 	~5 даёт -6.

# Логического выражения и логический тип данных

У этого типа всего два возможных значения: True (правда) — 1 и False (ложь) — 0. Только эти значения могут быть результатом логических выражений.

## Логические операторы

В языках программирования используются специальные знаки, подобные тем, которые используются в математических выражениях: > (больше), < (меньше), >= (больше или равно), <= (меньше или равно).


- < 	Меньше 	Определяет, верно ли, что x меньше y. Все операторы сравнения возвращают True или False. Обратите внимание на заглавные буквы в этих словах. 	

    5 < 3 даст False,

    а 3 < 5 даст True.

Можно составлять произвольные цепочки сравнений: 3 < 5 < 7 даёт True.

- > 	Больше 	Определяет, верно ли, что x больше y 	5 > 3 даёт True. Если оба операнда - числа, то перед сравнением они оба преобразуются к одинаковому типу. В противном случае всегда возвращается False.
- <= 	Меньше или равно 	Определяет, верно ли, что x меньше или равно y 	x = 3; y = 6; x <= y даёт True.
- >= 	Больше или равно 	Определяет, верно ли, что x больше или равно y 	x = 4; y = 3; x >= 3 даёт True.
- == 	Равно 	Проверяет, одинаковы ли объекты 	x = 2; y = 2; x == y даёт True. x = 'str'; y = 'stR'; x == y даёт False. x = 'str'; y = 'str'; x == y даёт True.
- != 	Не равно 	Проверяет, верно ли, что объекты не равны 	x = 2; y = 3; x != y даёт True.

## Сложные логические выражения

Может понадобиться получить ответа "Да" или "Нет" в зависимости от результата выполнения двух простых выражений.

В таких случаях используются специальные операторы, объединяющие два и более простых логических выражения. Широко используются два способа объединения: через, так называемые, логические И (and) и ИЛИ (or).

Чтобы получить истину (True) при использовании оператора and, необходимо, чтобы результаты обоих простых выражений, которые связывает данный оператор, были истинными. Если хотя бы в одном случае результатом будет False (ложь), то и все сложное выражение будет ложным.

Чтобы получить истину (True) при использовании оператора or, необходимо, чтобы результаты хотя бы одного простого выражения, входящего в состав сложного, был истинным. В случае оператора or сложное выражение становится ложным лишь тогда, когда ложны все составляющие его простые выражения.

- not 	Логическое НЕ 	Если x равно True, оператор вернёт False. Если же x равно False, получим True. 	x = True; not x даёт False.
- and 	Логическое И 	x and y даёт False, если x равно False , в противном случае возвращает значение y 	x = False; y = True; x and y возвращает False, поскольку x равно False. В этом случае Python не станет проверять значение y, так как уже знает, что левая часть выражения ‘and’ равняется False, что подразумевает, что и всё выражение в целом будет равно False, независимо от значений всех остальных операндов. Это называется укороченной оценкой булевых (логических) выражений.
- or 	Логическое ИЛИ 	Если x равно True, в результате получим True, в противном случае получим значение y 	x = True; y = False; x or y даёт True. Здесь также может производиться укороченная оценка выражений.

## Краткая запись мат. операций и присваивания

Зачастую результат проведения некой математической операции необходимо присвоить переменной, над которой эта операция производилась. Для этого существуют краткие формы записи выражений:

Вы можете записать:

    a = 2; a = a * 3

в виде:

    a = 2; a *= 3

# calc1.py

    elif (operator == "/" or operator == "//" or operator == "%" ) and y==0:
        print 'integer division or modulo by zero'
    elif operator == "/" and y !=0:
        print ("{} / {} = {}".format(x, y, x / y))
    elif operator == "//" and y !=0:
        print ("{} // {} = {}".format(x, y, x // y))
    elif operator == "%" and y !=0:
        print ("{} % {} = {}".format(x, y, x % y))

# Поток команд

В программах, которые мы до сих пор рассматривали, последовательность команд всегда выполнялась Python по порядку строго сверху вниз. А что, если нам необходимо изменить поток выполняющихся команд? Например, если требуется, чтобы программа принимала некоторое решение и выполняла различные действия в зависимости от ситуации.

В Python есть три оператора управления потоком: if, for и while.

# Оператор if

Оператор if используется для проверки условий: если условие верно, выполняется блок выражений (называемый “if-блок”), иначе выполняется другой блок выражений (называемый “else-блок”). Блок “else” является необязательным.

#   Оператор while

Оператор while позволяет многократно выполнять блок команд до тех пор, пока выполняется некоторое условие. Это один из так называемых операторов цикла. Он также может иметь необязательный пункт else.

## Пример:

        number = 23
        running = True

        while running:
            guess = int(input('Введите целое число : '))

            if guess == number:
                print('Поздравляю, вы угадали.')
                running = False # это останавливает цикл while
            elif guess < number:
                print('Нет, загаданное число немного больше этого')
            else:
                print('Нет, загаданное число немного меньше этого.')
        else:
            print('Цикл while закончен.')
            # Здесь можете выполнить всё что вам ещё нужно

        print('Завершение.')


В этой программе мы продолжаем играть в игру с угадыванием, но преимущество состоит в том, что теперь пользователь может угадывать до тех пор, пока не угадает правильное число, и ему не придётся запускать программу заново для каждой попытки, как это происходило до сих пор. Это наглядно демонстрирует применение оператора while.

Мы переместили операторы input и if внутрь цикла while и установили переменную running в значение True перед запуском цикла. Прежде всего проверяется, равно ли значение переменной running True, а затем происходит переход к соответствующему while-блоку. После выполнения этого блока команд условие, которым в данном случае является переменная running, проверяется снова. Если оно истинно, while-блок запускается снова, в противном случае происходит переход к дополнительному else-блоку, а затем – к следующему оператору.

Блок else выполняется тогда, когда условие цикла while становится ложным (False) – это может случиться даже при самой первой проверке условия. Если у цикла while имеется дополнительный блок else, он всегда выполняется, если только цикл не будет прерван оператором break.

## calc2.py
        # -*- coding:utf-8 -*-
        # ---------- CALCULATOR ----------
        '''
        To run under Python3 replace 'raw_input' call
        with 'input'
        Store the user input an operator
        '''
        print 'Super Calc'

        running = True

        while running:
            # Convert strings into integers
            x = float(raw_input("Enter x: "))
            y = float(raw_input("Enter y: "))

            # Store the user input an operator
            operator = raw_input('Enter Operator: ')

            if operator == 'q':
                print('Programm done.')
                running = False # это останавливает цикл while
            if operator == "+":
                print ("{} + {} = {}".format(x, y, x * y))

            # If the 1st condition wasn't true check if this one is
            elif operator == "-":
                print ("{} - {} = {}".format(x, y, x - y))
            elif operator == "*":
                print ("{} * {} = {}".format(x, y, x * y))
            elif (operator == "/" or operator == "//" or operator == "%" ) and y==0:
                print 'integer division or modulo by zero'
            elif operator == "/" and y !=0:
                print ("{} / {} = {}".format(x, y, x / y))
            elif operator == "//" and y !=0:
                print ("{} // {} = {}".format(x, y, x // y))
            elif operator == "%" and y !=0:
                print ("{} % {} = {}".format(x, y, x % y))

            # If none of the above conditions were true then execute this by default
            else:
                print ("Use either + - * / or % next time")


# Цикл for

Оператор for..in также является оператором цикла, который осуществляет итерацию по последовательности объектов, т.е. проходит через каждый элемент в последовательности.

## Пример:

        for i in range(1, 5):
            print(i)
        else:
            print('Цикл for закончен')

В этой программе мы выводим на экран последовательность чисел. Мы генерируем эту последовательность, используя встроенную функцию range.

Мы задаём два числа, и range возвращает последовательность чисел от первого числа до второго. Например, range(1,5) даёт последовательность [1, 2, 3, 4]. По умолчанию range принимает значение шага, равное 1. Если мы зададим также и третье число range, оно будет служить шагом. Например, range(1,5,2) даст [1,3]. Помните, интервал простирается только до второго числа, т.е. не включает его в себя.

Обратите внимание, что range() генерирует последовательность чисел, но только по одному числу за раз – когда оператор for запрашивает следующий элемент. Чтобы увидеть всю последовательность чисел сразу, используйте list(range()).

Затем цикл for осуществляет итерацию по этому диапазону - for i in range(1,5) эквивалентно for i in [1, 2, 3, 4], что напоминает присваивание переменной i по одному числу (или объекту) за раз, выполняя блок команд для каждого значения i. В данном случае в блоке команд мы просто выводим значение на экран.

Помните, что блок else не обязателен. Если он присутствует, он всегда выполняется один раз после окончания цикла for, если только не указан оператор break.

Помните также, что цикл for..in работает для любой последовательности. В нашем случае это список чисел, сгенерированный встроенной функцией range, но в общем случае можно использовать любую последовательность любых объектов!

# Оператор break

Оператор break служит для прерывания цикла, т.е. остановки выполнения команд даже если условие выполнения цикла ещё не приняло значения False или последовательность элементов не закончилась.

Важно отметить, что если циклы for или while прервать оператором break, соответствующие им блоки else выполняться не будут.

Пример:

        while True:
            s = input('Введите что-нибудь : ')
            if s == 'выход':
                break
            print('Длина строки: ', len(s))
        print('Завершение')

В этой программе мы многократно считываем пользовательский ввод и выводим на экран длину каждой введённой строки. Для остановки программы мы вводим специальное условие, проверяющее, совпадает ли пользовательский ввод со строкой 'выход'. Мы останавливаем программу прерыванием цикла оператором break и достигаем её конца.

Длина введённой строки может быть найдена при помощи встроенной функции len.

Оператор break может применяться и в цикле for.

## calc3.py

        while True:
            # Convert strings into integers
            x = float(raw_input("Enter x: "))
            y = float(raw_input("Enter y: "))

            # Store the user input an operator
            operator = raw_input('Enter Operator: ')

            if operator == 'q':
                print('Programm exit.')
                break
            if operator == "+":
                print ("{} + {} = {}".format(x, y, x * y))

# Оператор continue

Оператор continue используется для указания Python, что необходимо пропустить все оставшиеся команды в текущем блоке цикла и продолжить со следующей итерации цикла.

## Пример:

        while True:
            s = input('Введите что-нибудь : ')
            if s == 'выход':
                break
            if len(s) < 3:
                print('Слишком мало')
                continue
            print('Введённая строка достаточной длины')
            # Разные другие действия здесь...

В этой программе мы запрашиваем ввод со стороны пользователя, но обрабатываем введённую строку только если она имеет длину хотя бы в 3 символа. Итак, мы используем встроенную функцию len для получения длины строки, и если длина менее 3, мы пропускаем остальные действия в блоке при помощи оператора continue. В противном случае все остальные команды в цикле выполняются, производя любые манипуляции, которые нам нужны.

Оператор continue также работает и с циклом for.

## calc4.py

    if operator not in ('+','-','*','/','//','%','**'):
        print ("Help: Use either + - * / or % next time")
        continue

# Строки в Python  — это последовательности символов (codepoints)

- нет разницы между одинарными и двойными кавычками,
- символ строки это тоже строка,
- можно использовать тройные кавычки для многострочных блоков текста.
- Для форматирования строк следует использовать метод format, но полезно знать также про синтаксис с использованием оператора % .

## Строковые литералы

Можно использовать двойные или одинарные кавычки:

        "foobar" == 'foobar'

Для многострочных блоков текста используют тройные кавычки:
        """foo
        ... bar"""

Подряд идущие строковые литералы “склеиваются”:

        "foo" "bar"

        str1 = 'First line.\nSecond line.'  # \n means newline
        print(str1)
        print('C:\some\name')  # here \n means newline!
        print r'C:\some\name'  # note the r before the quote

        print """\
        Usage: thingy [OPTIONS]
             -h                        Display this usage message
             -H hostname               Hostname to connect to
        """

Если потребуется записать длинный строковый литерал, занимающий две или более строк, но без использования тройных кавычек, то можно использовать один из приемов:

        #  -*- coding: utf-8 -*-
        t = "Это не самый лучший способ объединения двух длинных строк, " \
            "потому что он основан на использовании неуклюжего экранирования"
        s = ("Это отличный способ объединить две длинные строки, потому что он основан на конкатенации строковых литералов.")
        print t
        print s

# Calculator calc5.py

        # Program make a simple calculator that can add, subtract, multiply and divide using functions

        # define functions
        def add(x, y):
           """This function adds two numbers"""

           return x + y

        def subtract(x, y):
           """This function subtracts two numbers"""

           return x - y

        def multiply(x, y):
           """This function multiplies two numbers"""

           return x * y

        def divide(x, y):
           """This function divides two numbers"""

           return x / y


## def operator

        def function_name(parameter_1,parameter_2):
            {this is the code in the function}
            {more code}
            {more code}
            return {value to return to the main program}
        {this code isn't in the function}
        {because it isn't indented}
        #remember to put a colon ":" at the end
        #of the line that starts with 'def'

## return

        def function_name(parameter_1,parameter_2):
            {this is the code in the function}
            {more code}
            {more code}
            return {value to return to the main program}


## Passing Parameters to functions
Defining functions with parameters

        def function_name(parameter_1,parameter_2):
            {this is the code in the function}
            {more code}
            {more code}
            return {value (e.g. text or number) to return to the main program}

## how parameters work

        def funnyfunction(first_word,second_word,third_word):
            print "The word created is: " + first_word + second_word + third_word
            return first_word + second_word + third_word


## menu calc6.py

        def menu():
           print("Select operation.")
           print("+.Add")
           print("-.Subtract")
           print("*.Multiply")
           print("/.Divide")
           return raw_input("Enter choice(+|-|*|/):")

           operator = menu()

           if operator == 'q':
               print('Thankyou for using calculator.py!')
               break

## myhelp()

        def myhelp():
           print """\
           Usage operation:
                'h'                        Display this usage message
                '+'                        Add
                '-'                        Subtract
                '*'                        Multiply
                '/'                        Divide
                'q'                        Quit
                """

                if operator not in ('+','-','*','/','//','%','**'):

                    myhelp()
                    continue

## Экранирование последовательности и “сырые” строки
В языке Python символ перевода строки интерпретируется как завершающий символ инструкции, но не внутри круглых скобок (()), квадратных скобок ([ ]), фигурных скобок ({}) и строк в тройных кавычках.

### Символы перевода строки  
мы можем включать символы перевода строки в любые строковые литералы с помощью экранированной последовательности \п.

        def menu():
           print("Select operation.\n")
           print("+.Add")
           print("-.Subtract")
           print("*.Multiply")
           print("/.Divide\n")
           return raw_input("Enter choice(+|-|*|/):")

## Экранированные последовательности в языке Python

- \перевод_строки Экранирует (то есть игнорирует) символ перевода строки
- \\ Символ обратного слеша (\)
- \' одинарная кавычка
- \" двойная кавычка
- \t символ вертикальной табуляции
- \n символ переноса строки
- \xhh символ с HEX кодом hh
- \а Символ ASCII «сигнал» (bell, BEL)
- \b Символ ASCII «забой» (backspace, BS)
- \f Символ ASCII «перевод формата» (formfeed, FF)
- \N{название} Символ Юникода с заданным названием
- \ооо Символ с заданным восьмеричным кодом
- \r Символ ASCII «возврат каретки» (carriage return, CR)
- \t Символ ASCII «табуляция» (tab, TAB)
- \uhhhh Символ Юникода с указанным 16-битовым шестнадцатеричным значением
- \Uhhhhhhhh Символ Юникода с указанным 32-битовым шестнадцатеричным значением
- \v Символ ASCII «вертикальная табуляция» (vertical tab, VT)
- \xhh Символ с указанным 8-битовым шестнадцатеричным значением

Полный список поддерживаемых последовательностей можно прочитать в        документации http://bit.ly/escape-sequences

# Преобразование объекта в строку
В Python 3 есть три различных по смыслу способа преобразовать объект в строку:
- str возвращает человекочитаемое представление объекта,
- repr возвращает представление объекта, по которому можно однозначно восстановить его значение,
- ascii аналогичен repr по смыслу, но возвращаемая строка должна содержать только символы ASCII.

Примеры:

        str("я строка")

        repr("я строка")

        ascii("я строка")

        unicode("я строка")

## Форматирование строк:

s.format(...) Возвращает копию строки s, отформатированную в соответствии с заданными аргументами.

### Форматирование строк с помощью метода str.format()
В Python есть два способа форматирования строк. Первый использует метод format :

        "{}, {}, how are you?".format("Hello", "Sally")

        "Today is October, {}th.".format(8)

- {} обозначает место, в которое будет подставлен позиционный аргумент.

- Внутри {} можно опционально указать способ преобразования объекта в строку и спецификацию формата.

- Для преобразования объекта в строку используются первые буквы соответствующих функций:

        "{!s}".format("я строка") # str

        "{!r}".format("я строка") # repr

        "{!a}".format("я строка") # ascii

        "'\\u044f \\u0441\\u0442\\u0440\\u043e\\u043a\\u0430'"

## calc7.py

        if operator == 'q':
            print('{!r}'.format('Thankyou for using calculator.py!'))
            print('{!s}'.format('Thankyou for using calculator.py!'))
            break

## calc7_3.py

        if operator == 'q':
            print('{!r}'.format('Thankyou for using calculator.py!'))
            print('{!a}'.format('Thankyou for using calculator.py!'))
            print('{!s}'.format('Thankyou for using calculator.py!'))

            break


### Форматирование строк: спецификация формата

Спецификация формата позволяет:

- выровнять строку в “блоке” фиксированной длины,

        '{!r:~^40}'.format('Thankyou for using calculator.py!')

- привести число к другой системе исчисления,

        "int: {0:d} hex: {0:x}".format(42)

        "oct: {0:o} bin: {0:b}".format(42)

- потребовать наличие знака в строковом представлении числа и зафиксировать количество знаков до или после запятой.

        "{:+08.2f}".format(-42.42)

- Комбинированный пример:

    if operator == 'q':
        print('{!r:~^40}'.format('Thankyou for using calculator.py!'))
        print('{!s:#^40}'.format('Thankyou for using calculator.py!'))
        break

    elif operator == "-":
        print ("{:+08.2f} - {:+08.2f} = {:+08.2f}".format(x, y, subtract(x, y)))

### Форматирование строк: позиционные и ключевые аргументы

- Внутри {} можно также явно указывать номер позиционного или имя ключевого аргумента:

        "{0}, {1}, {0}".format("hello", "kitty")

        "{0}, {who}, {0}".format("hello", who="kitty")

        elif operator == "*":
            print ("{0} * {k} = {1}".format(x, multiply(x, y), k=y))

- Если один из аргументов — контейнер, то при форматировании можно обращаться к его элементам по индексу или ключу:

        point = 0, 10
        "x = {0[0]}, y = {0[1]}".format(point)

        point = {"x": 0, "y": 10}
        "x = {0[x]}, y = {0[y]}".format(point)

Каждое замещаемое поле идентифицируется именем поля в фигурных скобках. Если в качестве имени поля используется целое число, оно определяет порядковый номер аргумента, переданного методу str. formate). Поэтому в данном случае поле с именем 0 было замещено первым аргументом, а поле с именем 1 - вторым аргументом. Если бы нам потребовалось включить фигурные скобки в строку формата, мы могли бы сделать это, дублируя их, как показано ниже:

         "{{{0}}} {1} ;-}}".format('I'm in braces", "I'm not")

Если попытаться объединить строку и число, интерпретатор Python совершенно справедливо возбудит исключение ТуреЕггог. Но это легко можно сделать с помощью метода str.format():

        record ="{0}{1}".format("The amount due is $", 200)
        print(record)

С помощью str.format() мы также легко можем объединять строки (хотя для этой цели лучше подходит метод str.join()):

        х = "three"
        s ="{0} {1} {2}"
        s = s.format("The", x, "tops")
        print(s)

### Форматирование строк: олдскул

Второй способ форматирования строк в Python использует оператор % и внешне похож на printf :

        "%s, %s, how are you?" % ("Hello", "Sally")

        point = {"x": 0, "y": 10}
        "x = %(x)+2d, y = %(y)+2d" % point

- Он менее выразителен и гибок чем format :
- % — бинарный оператор, справа от него может быть один аргумент: кортеж или словарь,
- нельзя использовать позиционный аргумент более одного раза,
- нет синтаксиса для обращения к элементам контейнера или атрибутам объекта,
- не предусмотрена возможность расширения, например, если потребуется форматировать длинные числа с плавающей точкой, то синтаксис "%8.2f" для них работать не будет.


## format calc7.py

        # -*- coding:utf-8 -*-
        # ---------- CALCULATOR ----------
        '''
         Program make a simple calculator that can add, subtract, multiply and divide using functions
        '''
        print 'Super Calc'

        # define functions
        def add(x, y):
           """This function adds two numbers"""

           return x + y

        def subtract(x, y):
           """This function subtracts two numbers"""

           return x - y

        def multiply(x, y):
           """This function multiplies two numbers"""

           return x * y

        def divide(x, y):
           """This function divides two numbers"""

           return float(x / y)

        def intdivide(x, y):
           """This function int divides two numbers"""

           return x // y

        def modulo(x,y):
            """This function modulos two numbers"""

            return x % y

        def menu():
           print("Select operation.\n")
           print("+.Add")
           print("-.Subtract")
           print("*.Multiply")
           print("/.Divide\n")

           return str(raw_input("Enter choice(+|-|*|/):"))

        def myhelp():
           print """\
           Usage operation:
                'h'                        Display this usage message
                '+'                        Add
                '-'                        Subtract
                '*'                        Multiply
                '/'                        Divide
                'q'                        Quit
                """

        while True:
            # Convert strings into integers
            x = float(raw_input("Enter x: "))
            y = float(raw_input("Enter y: "))

            # Store the user input an operator
            # operator = raw_input('Enter Operator: ')
            operator = menu()

            if operator == 'q':
                print('{!r:~^40}'.format('Thankyou for using calculator.py!'))
                print('{!s:#^40}'.format('Thankyou for using calculator.py!'))
                break

            if operator not in ('+','-','*','/','//','%','**'):
                # print ("Help: Use either + - * / or % next time")
                myhelp()
                continue

            if operator == "+":
                print ("{} + {} = {}".format(x, y, add(x, y)))
                print ("int: {0:d} hex: {0:x} + int: {1:d} hex: {1:x}  =  int: {2:d} hex: {2:x}".format(int(x), int(y), int(add(x, y))))
                print ("oct: {0:o} bin: {0:b} + oct: {1:o} bin: {1:b}  =  oct: {2:o} bin: {2:b}".format(int(x), int(y), int(add(x, y))))

            elif operator == "-":
                print ("{:+08.2f} - {:+08.2f} = {:+08.2f}".format(x, y, subtract(x, y)))
            elif operator == "*":
                print ("{0} * {k} = {1}".format(x, multiply(x, y), k=y))
            elif (operator == "/" or operator == "//" or operator == "%" ) and y==0:
                print 'integer division or modulo by zero'
            elif operator == "/" and y !=0:
                print ("{0:+08.2f} / {1:+08.2f} = {2:+08.2f}".format(x, y, divide(x, y)))
            elif operator == "//" and y !=0:
                print ("{} // {} = {}".format(x, y, intdivide(x, y)))
            elif operator == "%" and y !=0:
                print ("{} % {} = {}".format(x, y, modulo(x, y)))

            # If none of the above conditions were true then execute this by default
            else:
                print ("*")

# Строковые методы

### Методы работы со строками: модификаторы регистра

- s.capitalize() Возвращает копию строки s с первым символом в верхнем регистре;

- s.swapcase() Возвращает копию строки s, в которой все символы верхнего регистра преобразованы в символы нижнего регистра, а все символы нижнего регистра - в символы верхнего регистра;

- s.title() Возвращает копию строки s, в которой первые символы каждого слова преобразованы в символы верхнего регистра, а все остальные символы - в символы нижнего регистра;

- s.upper() Возвращает копию строки s, в которой все символы приведены к верхнему регистру;

- s.zfill(w) Возвращает копию строки s, которая, если ее длина меньше величины w, дополняется слева нулями до длины w

        "foo bar".capitalize()

        "foo bar".title()

        "foo bar".upper()

        "foo bar".lower()

        "foo bar".title().swapcase()


### Методы работы со строками: выравнивание
Группа методов, заканчивающихся на just , выравнивает строку в “блоке” фиксированной длины. При этом дополнительные позиции заполняются указанным         символом:

        "foo bar".ljust(16, '~')

        "foo bar".rjust(16, '~')

- s.center(width, char) Возвращает копию строки s, отцентрированную в строке с длиной width. Недостающие символы по умолчанию  заполняются пробелами или символами в соответствии с необязательным аргументом char (строка с длиной, равной 1);

        "foo bar".center(16, '~')

В качестве символа по умолчанию используется пробел
Если длина “блока” меньше длины строки, то строка возвращается без изменений.

## calc8.py
        def menu():
            print 'Super Calc'.upper().center(30, '='), '\n'
            print("Select operation:").title().rjust(30, '|'), '\n'
            print("+ : Add").capitalize()
            print("- : Subtract").swapcase()
            print("* : Multiply").lower()
            print("/ : Divide\n").title()

            return raw_input("Enter choice(+|-|*|/|**):".title())


- s.count(t, start, end) Возвращает число вхождений строки t в строку s (или в срез строки s[start:end])

- s.encode(encoding, err) Возвращает объект типа bytes, представляющий строку в кодировке по умолчанию или в кодировке, определяемой аргументом encoding, с обработкой ошибок, определяемой необязательным аргументом err

- s.expandtabs(size) Возвращает копию строки s, в которой символы табуляцш замещены пробелами с шагом 8 или в соответствии со значе нием необязательного аргумента size

        str2 = "interpreter the output"
        print(str2.capitalize())
        print(str2.center(30))
        print(str2.center(30,'#'))
        print(str2.count('the'))
        print(str2.count('the',3,20))
        print(str2.encode())
        print(str2.encode('utf-8'))
        print(str2.encode('ascii'))
        print(str2.endswith('output'))
        print(str2.endswith(('the', 'output')))
        print(str2.startswith('inter'))

# Операторы и методы строк
Поскольку строки относятся к категории неизменяемых последовательностей, все функциональные возможности, применимые к неизменяемым последовательностям, могут использоваться и со строками. Сюда входят оператор проверки на вхождение in, оператор конкатенации +, оператор добавления в конец +=, оператор дублирования * и комбинированный оператор присваивания с дублированием *=.

# Оператор * обеспечивает возможность дублирования строки:

        s = «=» * 5

        def menu():
            print 'Super Calc'.upper().center(30, '=')
            print("_"*30)
            print('| Select operation:')
            print '|'+"_"*28+'|'
            print("| + : Add").capitalize()
            print("| - : Subtract").swapcase()
            print("| * : Multiply").lower()
            print("| / : Divide").title()
            print("_"*30)
            return raw_input("| Enter choice(+|-|*|/|**):".title())

мы можем также использовать комбинированный оператор присваивания с дублированием.

        3 * 'un' + 'ium'

        'Py' 'thon'

        text = ('Put several strings within parentheses '
                    'to have them joined together.')

Так как строки являются последовательностями, они являются объектами, имеющими «размер», и поэтому мы можем вызывать функцию lеп(), передавая ей строки в качестве аргумента. Возвращаемая функцией длина представляет собой количество символов в строке (ноль - для пустых строк).

перегруженная версия оператора + для строк выполняет операцию конкатенации. В случаях, когда требуется объединить множество строк, лучше использовать метод str.join(). Метод принимает в качестве аргумента последовательность (то есть список или кортеж строк) и объединяет их в единую строку, вставляя между ними строку, относительно которой был вызван метод. Например:

        def menu():
            print 'Super Calc'.upper().center(30, '=')
            print("_"*30)
            str1 = 'Select operation:'
            print('|'+str1+' '*(28-len(str1))+'|')
            print '|'+"_"*28+'|'
            print("| + : Add").capitalize().ljust(29,' ')+'|'
            print("| - : Subtract").swapcase().ljust(29,' ')+'|'
            print("| * : Multiply").lower().ljust(29,' ')+'|'
            print("| / : Divide").title().ljust(29,' ')+'|'
            print("="*30)
            return raw_input("| Enter choice(+|-|*|/|**):".title())

## С помощью метода join можно соединить любую последовательность строк:

        ", ".join(["foo", "bar", "baz"])

        ", ".join(filter(None, ["", "foo"]))

        ", ".join("bar")

- Если последовательность содержит объекты другого типа, будет ошибка:

        ", ".join(range(10))


        str2 = ["In the interactive", "interpreter", "the output"]
        print("".join(str2))
        print("-".join(str2))
        print(" ".join(str2))

Первый пример является, пожалуй, наиболее типичным; он объединяет строки из списка, вставляя между ними единственный символ, в данном случае - пробел. Третий пример представляет собой операцию конкатенации в чистом виде - благодаря тому что метод вызывается относительно пустой строки, строки объединяются без добавления чего бы то ни было между ними.

## Default choice

        def menu():
            print 'Super Calc'.upper().center(30, '=')
            print("_"*30)
            str1 = 'Select operation:'
            print('|'+str1+' '*(28-len(str1))+'|')
            print '|'+"_"*28+'|'
            print("| + : Add").capitalize().ljust(29,' ')+'|'
            print("| - : Subtract").swapcase().ljust(29,' ')+'|'
            print("| * : Multiply").lower().ljust(29,' ')+'|'
            print("| / : Divide").title().ljust(29,' ')+'|'
            print("="*30)

            choice = raw_input("| Enter choice(+|-|*|/|**):".title())
            return str(choice) if choice != '' else 'h'

## Получение срезов строк
отдельные элементы последовательности, а, следовательно, и отдельные символы в строках, могут извлекаться с помощью оператора доступа к элементам ([ ]). В действительности этот оператор намного более универсальный и может использоваться для извлечения не только одного символа, но и целых комбинаций (подпоследовательностей) элементов или символов, когда этот оператор используется в контексте оператора извлечения среза.

Нумерация позиций символов в строках начинается с 0 и продолжается до значений длины строки минус 1. Однако допускается использовать и отрицательные индексы - в этом случае отсчет начинается с последнего символа и ведется в обратном направлении к первому символу.

## Номера позиций символов в строке
Отрицательные индексы удивительно удобны, особенно индекс -1, который всегда соответствует последнему символу строки. Попытка обращения к индексу, находящемуся за пределами строки (или к любому индексу в пустой строке), будет вызывать исключение IndexError. Оператор получения среза имеет три формы записи:

        seq[start]
        seq[start:end]
        seq[start;end:step]

Значения start, end и step должны быть целыми числами (или переменными, хранящими целые числа).

Вторая форма записи извлекает подстроку, начиная с элемента с индексом start и заканчивая элементом с индексом end, не включая его. При использовании второй формы записи (с одним двоеточием) мы можем опустить любой из индексов. Если опустить начальный индекс, по умолчанию будет использоваться значение 0. Если опустить конечный индекс, по умолчанию будет использоваться значение len(seq). Это означает, что если опустить оба индекса, например, s[: ], это будет равносильно выражению s[0:len(s)], и в результате будет извлечена, то есть скопирована, последовательность целиком.

        str1 ="In the interactive interpreter"
        str2 ="In the interactive interpreter, the output"
        print (str1[1])
        print (str2[9])
        print (str2[1:9])
        print (str2[-9])
        print (str2[0:])
        print (str2[:-1])
        print (str2[:])
        print (str2[0:len(str2)])

## Извлечение срезов из последовательности
Один из способов вставить подстроку в строку состоит в смешивании операторов извлечения среза и операторов конкатенации. Например:

        str2 ="In the interactive interpreter, the output"
        print (str2[:12] + 'test' + str2[12:])

Кроме того, поскольку текст «the» присутствует в оригинальной строке, тот же самый эффект можно было бы получить путем присваивания значения выражения print (str2[:12] + str2[3:6] + str2[12:]).

Оператор конкатенации + и добавления подстроки += не особенно эффективны, когда в операции участвует множество строк. Для объединения большого числа строк обычно лучше использовать метод str.join().

        str2 ="In the interactive interpreter, the output"
        print(str2[0:12:1])
        print(str2[::3])
        print(str2[::-3])
        print(str2[20::-3])
        print(str2[50::-1])

Операция извлечения элементов с определенным шагом часто применяется к последовательностям, отличным от строк, но один из ее вариантов часто применяется к строкам:

        s, s[: :-1]

Шаг -1 означает, что будет извлекаться каждый символ, от конца до начала, то есть будет получена строка, в которой символы следуют в обратном порядке.

## Методы работы со строками: разделение
- s.split(t, n) Возвращает список строк, выполняя разбиение строки s не более чем п раз по подстроке t. Если число п не задано, разбиение выполняется по всем найденным подстрокам t. Если подстрока t не задана, разбиение выполняется по пробельным символам. Для выполнения разбиения строки, начиная с правого края, используйте метод str. rsplit - этот метод имеет смысл применять, когда задано число разбиений п, которое меньше максимального числа возможных разбиений
Метод split разделяет строку на подстроки по указанному разделителю:

        "foo,bar".split(",")

        "foo,,,bar".split(",")

- Несложно догадаться, что если разделитель не указан, то строка разделяется по пробелам.

        "\t foo bar \r\n

- Метод partition возвращает кортеж из трех элементов:
подстрока до вхождения разделителя, разделитель и подстрока после вхождения разделителя.
- s.partition(t) Возвращает кортеж из трех строк - часть строки s перед самым первым (крайним слева) вхождением подстроки t, t и часть строки s после подстроки t; если подстрока t в строке s отсутствует, возвращаются строка s и две пустые строки.
Для деления строки по самому последнему (крайнему справа) вхождению подстроки t, используйте метод str.Rpartition()

        "foo,bar,baz".partition(",")

        "foo,bar,baz".rpartition(",")

- s.splitlines Возвращает список строк, выполняя разбиение строки s по символам перевода строки, удаляя их, если в аргументе f не задано значение True


## Методы работы со строками: проверка на вхождение
Вхождение построки идиоматично проверять с помощью операторов in и not in:

        "foo" in "foobar"

        "yada" not in "foobar"

Можно также сравнить префикс или суффикс строки с данной строкой или строками:

- s.endswith(x, start, end) Возвращает True, если строка s (или срез строки s[start:end] оканчивается подстрокой х или любой из строк, если х - кортеж; в противном случае возвращает False.
- s.startswith (x, start, end) Возвращает True, если строка s (или срез строки s[ start: end]) начинается подстрокой х или любой из строк, если х - кортеж; в противном случае возвращает False.

        "foobar".startswith("foo")

        "foobar".endswith(("boo", "bar"))

## Методы работы со строками: предикаты
Методы-предикаты позволяют проверить строку на соответствие некоторому формату, например:

                "100500".isdigit()

                "foo100500".isalnum()

                "foobar".isalpha()

Другие полезные предикаты:

                "foobar".islower()

                "FOOBAR".isupper()

                "Foo Bar".istitle()

                "\r\n\t \r\n".isspace()

- s.isalnum() Возвращает True, если строка s не пустая и содержит только алфавитно-цифровые символы
- s.isalpha() Возвращает True, если строка s не пустая и содержит только алфавитные символы
- s.isdecimal() Возвращает True, если строка s не пустая и содержит только символы Юникода, обозначающие цифры десятичной системы счисления
- s.isdigit() Возвращает True, если строка s не пустая и содержит только символы ASCII, обозначающие цифры десятичной системы счисления
- s.isidentifier() Возвращает True, если строка s не пустая и является допустимым идентификатором

                str2 = "interpreter the output"
                st1 = "123456"
                st2 = "Abcd"
                st4 = "ABC"
                st3 = "   "
                print(st1.isalnum())
                print(st2.isalpha())
                print(str2.isdigit())
                print(str2.islower())
                print(st1.isspace())
                print(st3.isspace())
                print(st2.isupper())
                print(st4.isupper())

- s.islower() Возвращает True, если строка s имеет хотя бы один символ, который может быть представлен в нижнем регистре, и все такие символы находятся в нижнем регистре;
- s.isnumeric() Возвращает True, если строка s не пустая и содержит только символы Юникода, используемые для обозначения чисел
- s.isprintable() Возвращает True, если строка s пустая или содержит только печатаемые символы, включая пробел, но не символ перевода строки
- s.isspace() Возвращает True, если строка s не пустая и содержит только пробельные символы
- s.istitle() Возвращает True, если строка s не пустая и имеет формат заголовка;
- s.isupper() Возвращает True, если строка s имеет хотя бы один символ, который может быть представлен в верхнем регистре, и все такие символы находятся в верхнем регистре;

## calc10.py

        if choice == 'c':
            a,operator,b = raw_input("Enter x operator y: ").split()

            x = float(a) if a.isdigit() else myhelp(); continue
            y = float(b) if b.isdigit() else myhelp(); continue

## Методы работы со строками: поиск подстроки

Найти индекс первого вхождения подстроки можно с помощью метода find :

s.find(t, start, end) Возвращает позицию самого первого (крайнего слева) вхождения подстроки t в строку s (или в срез строки s[start:end]) если подстрока t не найдена, возвращается -1. Для поискa самого последнего (крайнего справа) вхождения следует использовать метод str.rfind().

        "abracadabra".find("ra")

        "abracadabra".find("ra", 0, 3)

- Метод index аналогичен find , но если искомая подстрока не найдена, он поднимает исключение:

        "abracadabra".index("ra", 0, 3)
        Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
        ValueError: substring not found

- Можно также поинтересоваться последним вхождением подстроки с помощью методов rfind и rindex .
- s.index(t, start, end)  Возвращает позицию самого первого (крайнего слева) вхождения подстроки t в строку s (или в срез строки s[start\end]); если подстрока t не найдена, возбуждается исключение ValueError. Для поиска самого последнего (крайнего справа) вхождения следует использовать метод str.rfind()

        str2 = "interpreter the output"
        print(str2.find('the'))
        print(str2.find('the',5,20))
        print(str2.find('the',5,8))
        print(str2.rfind('the'))
        print(str2.index('the'))


- s.join(seq) Объединяет все элементы последовательности seq, вставляя между ними строку s (которая может быть пустой строкой)
- s.ljust(width, char)  Возвращает копию строки s, выровненной по левому краю, в строке длиной width. Недостающие символы по умолчанию заполняются пробелами или символами в соответствии с необязательным аргументом char (строка с длиной, равной 1). Для выравнивания по правому краю используйте метод str.rjust(), для выравнивания по центру - метод Str.center ();
- s.lower() Возвращает копию строки s, в которой все символы приведены к нижнему регистру;
- s.maketrans() Парный метод для str.translate(); подробности приводятся в тексте

## Методы работы со строками: замена подстроки
- s.replace (t, u, n) Возвращает копию строки s, в которой каждое (но не более п, если этот аргумент определен) вхождение подстроки t замещается подстрокой
Метод replace заменяет все вхождения подстроки на заданную строку:

        "abracadabra".replace("ra", "**")

        "abracadabra".replace("ra", "**", 1)

### Методы работы со строками: удаление символов
- s.strip(c/?ars) Возвращает копию строки s, из которой удалены начальные и завершающие пробельные символы (или символы, входящие в строку chars).
- Метод str.lstrip() выполняет удаление только в начале строки  
- метод str. rstrip() - только в конце
Группа методов, заканчивающихся на strip, удаляет все вхождения указанных символов слева, справа или с обоих концов строки:

        "]>>foo bar<<[".lstrip("]>")

        "]>>foo bar<<[".rstrip("[<")

        "]>>foo bar<<[".strip("[]<>")

По умолчанию удаляются все пробелы

## calc11.py

        ops = ('+','-','*','/','//','%','**')
        while True:

            choice = menu()

            if choice == 'q':
                print('{!s:#^40}'.format('Thankyou for using calculator.py!'))
                break
            if choice == 'h':
                myhelp()
                continue
            if choice == 'c':
                entry = raw_input("Enter x operator y: ")

                for o in ops:
                    index = entry.find(o)
                    if index != -1:
                        operator = o
                        a,b = entry.split(o)
                        a = a.strip()
                        b = b.strip()

                if a.isdigit():
                    x = float(a)
                else:
                    myhelp()
                    continue

                if b.isdigit():
                    y = float(b)
                else:
                    myhelp()
                    continue

                if operator not in ('+','-','*','/','//','%','**'):
                    myhelp()
                    continue


Когда оператор проверки на вхождение in применяется к строкам, он возвращает True, если операнд слева является подстрокой операнда справа или равен ему. Когда необходимо точно определить позицию подстроки в строке, можно использовать два метода. Первый метод str.index() возвращает позицию подстроки в строке или возбуждает исключение ValueError, если подстрока не будет найдена. Второй метод str.find() возвращает позицию подстроки в строке или -1 в случае неудачи. Оба метода принимают искомую подстроку в качестве первого аргумента и могут принимать еще пару необязательных аргументов.

## str.count() calc12.py
        # -*- coding:utf-8 -*-
        # ---------- CALCULATOR ----------
        '''
         Program make a simple calculator that can add, subtract, multiply and divide using functions
        '''

        # define functions
        def add(x, y):
           """This function adds two numbers"""

           return x + y

        def subtract(x, y):
           """This function subtracts two numbers"""

           return x - y

        def multiply(x, y):
           """This function multiplies two numbers"""

           return x * y

        def divide(x, y):
           """This function divides two numbers"""

           return float(x / y)

        def intdivide(x, y):
           """This function int divides two numbers"""

           return x // y

        def modulo(x,y):
            """This function modulos two numbers"""
            return x % y

        def menu():
            print 'Super Calc'.upper().center(30, '=')
            print("_"*30)
            str1 = 'Select operation:'
            print('|'+str1+' '*(28-len(str1))+'|')
            print '|'+"_"*28+'|'
            print("| c : Calculate").ljust(29,' ')+'|'
            print("| h : Help").ljust(29,' ')+'|'
            print("| q : Quit").ljust(29,' ')+'|'

            print("="*30)

            choice = raw_input("| Enter choice(h|c|q):".title())
            return str(choice) if choice != '' else 'h'

        def myhelp():
           print """\
           Usage operation:
                'h'                        Display this usage message
                'c'                        Calculate
                'q'                        Quit
                """

        ops = ('+','-','*','/','//','%','**')

        def extacts(entry,o):
            index = entry.find(o)
            if index != -1:
                a,b = entry.split(o)
                a = a.strip()
                b = b.strip()
            return (a,b,o)

        while True:

            choice = menu()

            if choice == 'q':
                print('{!s:#^40}'.format('Thankyou for using calculator.py!'))
                break
            if choice == 'h':
                myhelp()
                continue
            if choice == 'c':
                entry = raw_input("Enter x operator y: ")

                for o in ops:
                    if entry.count(o) == 1:
                        a,b,operator = extacts(entry,o)
                    if entry.count(o) == 2:

                        a,b,operator = extacts(entry,2*o)

                if a.isdigit():
                    x = float(a)
                else:
                    myhelp()
                    continue

                if b.isdigit():
                    y = float(b)
                else:
                    myhelp()
                    continue

                if operator not in ('+','-','*','/','//','%','**'):
                    myhelp()
                    continue

                if operator == "+":
                    print ("{} + {} = {}".format(x, y, add(x, y)))

                elif operator == "-":
                    print ("{:+08.2f} - {:+08.2f} = {:+08.2f}".format(x, y, subtract(x, y)))

                elif operator == "*":
                    print ("{0} * {k} = {1}".format(x, multiply(x, y), k=y))

                elif (operator == "/" or operator == "//" or operator == "%" ) and y==0:
                    print 'integer division or modulo by zero'

                elif operator == "/" and y !=0:
                    print ("{0:+08.2f} / {1:+08.2f} = {2:+08.2f}".format(x, y, divide(x, y)))

                elif operator == "//" and y !=0:
                    print ("{} // {} = {}".format(x, y, intdivide(x, y)))

                elif operator == "%" and y !=0:
                    print ("{} % {} = {}".format(x, y, modulo(x, y)))
