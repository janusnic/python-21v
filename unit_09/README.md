# основные идеи ООП:
1. наследование. Возможность выделять общие свойства и методы классов в один класс верхнего уровня (родительский). Классы, имеющие общего родителя, различаются между собой за счет включения в них различных дополнительных свойств и методов.
<br>
2. Инкапсуляция. Свойства и методы класса делятся на доступные из вне (опубликованные) и недоступные (защищенные). Защищенные атрибуты нельзя изменить, находясь вне класса. Опубликованные же атрибуты также называют интерфейсом объекта, т. к. с их помощью с объектом можно взаимодействовать. 
<br>
3. Полиморфизм. Полиморфизм подразумевает замещение атрибутов, описанных ранее в других классах: имя атрибута остается прежним, а реализация уже другой. Полиморфизм позволяет специализировать (адаптировать) классы, оставляя при этом единый интерфейс взаимодействия.

# Особенности ООП в Python
1. Любое данное — это объект. Число, строка, список, массив и др. — все является объектом. Бывают объекты встроенных классов, а бывают объекты пользовательских классов. Для единого механизма взаимодействия предусмотрены методы перегрузки операторов.
<br>
2. Класс — это тоже объект с собственным пространством имен.  
<br>
3. Инкапсуляции в Python не уделяется особого внимания. В других языках программирования обычно нельзя получить напрямую доступ к свойству, описанному в классе. Для его изменения может быть предусмотрен специальный метод. В Python же это легко сделать, просто обратившись к свойству класса из вне. Несмотря на это в Python все-таки предусмотрены специальные способы ограничения доступа к переменным в классе.

# Инкапсуляция
<pre>
class Foo(object):
	"""docstring for Foo 
       Одиночное подчеркивание в начале имени атрибута говорит о том, 
       что переменная или метод не предназначен для использования 
       вне методов класса, однако атрибут доступен по этому имени
	"""
    def _private(self):
       	print("Это приватный метод!")
	arg1 = None 
	_arg2 = None 
	__arg3 = None 
	def __init__(self): 
		super(Foo, self).__init__() 
	def bar(self): 
		pass


a = Foo()
a._private() # Это приватный метод!

class Bar(object):
	"""docstring for Foo 
       Двойное подчеркивание в начале имени атрибута: 
       атрибут становится недоступным по этому имени.
	"""
    def __private(self):
        print("Это приватный метод!")

b = Bar()
b.__private()
</pre>
Однако полностью это не защищает, так как атрибут всё равно остаётся доступным под именем _ИмяКласса__ИмяАтрибута:
<pre>
b._B__private()
Это приватный метод!
</pre>
1 Как получить список всех атрибутов объекта<br>
print dir(Foo)

2. Как получить список всех публичных атрибутов объекта
<br>
Сделать это можно или с помощью списковых выражений (list comprehension):
<br>
print [arg for arg in dir(Foo) if not arg.startswith('_')]
<br>
или воспользоваться функцией filter:
<br>
print filter(lambda x: not x.startswith('_'), dir(Foo))
<br>
3. Как получить список методов объекта
<br>
print [arg for arg in dir(Foo) if callable(getattr(Foo, arg))]
<br> или
print filter(lambda arg: callable(getattr(Foo, arg)), dir(Foo))
<br>
4. В какой «магической» переменной хранится содержимое help?
<br>
В атрибуте __doc__. В данную переменную заносится комментарий сразу после объявления класса/метода/функции (см. тестовый класс).
print Foo.__doc__
<br>
Так же можно воспользоваться функцией help в интерактивном режиме:
help(int)
<br>
# Наследование

<pre>
создать свой класс, похожий на словарь:

class Mydict(dict):
    def get(self, key, default = 0):
        return dict.get(self, key, default)
a = dict(a=1, b=2)
b = Mydict(a=1, b=2)

b['c'] = 4
print b # {'a': 1, 'c': 4, 'b': 2}
print a.get('v') # None
print b.get('v') # 0
</pre>
# Полиморфизм
<pre>
1 + 1
'1' + '1'
</pre>
Иногда бывает полезен тип данных, похожий на record из языка Pascal или struct из языка C, например, для хранения нескольких поименованных элементов данных. Для этой цели подойдет даже пустое определение класса:
<pre>
class Employee:
    pass

john = Employee() # Создать пустую запись о рабочем

# Заполнить поля записи
john.name = 'John Doe'
john.dept = 'computer lab'
john.salary = 1000
</pre>
# Singleton

можно написать реализацию паттерна одиночка. Мы должны гарантировать, что у класса есть только один экземпляр. Т.е. при вызове конструктора класса, всегда возвращаем один и тот же экземпляр класса.
<br>
А это значит, что при вызов метода __new__ должен возвращать каждый раз один и тот же объект. Хранить сам объект можно, например, в классовой переменной instance. В результате получаем:
<pre>
class C(object):
    instance = None
    def __new__(cls):
        if cls.instance is None:
            cls.instance = super(C, cls).__new__(cls)
        return cls.instance

C() is C() # True
C().x = 1
c = C()
d = C()
c.x # 1
d.x # 1
c.x=2 
d.x # 2
c.x # 2
</pre>
# Перегрузка операторов Наследование 
<pre>
class Newclass:
     def __init__(self, base):
          self.base = base
     def __add__(self, a):
          self.base = self.base + a
     def __str__(self):
          return "%s !!! " % self.base
 
a = Newclass(10)
a + 20
print (a)
 
b = Newclass("yes")
b + "terday"
print (b)
 
c = Newclass([2,6,3])
c + [7, 1]
print (c)
</pre>
Задание. Дополните класс методами __mul__ (вызывается при использовании объекта в операциях умножения) и__sub__ (вычитание). Вызовите данные методы с помощью соответствующих операций с объектами. Для каких объектов невозможно использовать метод __sub__?

# Перегрузка операторов
<pre>
class Number:
    def __init__(self, start):
        self.data = start
    def __sub__(self, other):
        return Number(self.data - other)
 
x = Number(5)
y = x - 2
print(y.data)
</pre>
# __call__ - перегрузка вызова функции
Метод __call__ автоматически вызывается, когда к объекту обращаются как к функции. Например, здесь во второй строке произойдет вызов метода __call__ некого Класса:
объект = некийКласс()
объект([возможные аргументы])
<pre>
# метод __call__ позволяет объектам вести себя как функции.

class Changeable:
     def __init__(self, color):
          self.color = color
     def __call__(self, newcolor):
          self.color = newcolor
     def __str__(self):
          return "%s" % self.color
 
canvas = Changeable("green")
frame = Changeable("blue")
 
canvas("red")
frame("yellow")
 
print (canvas, frame)
</pre>
Задание. Создайте класс с методом __call__, принимающим два параметра и производящим над ними те или иные математические операции. Создайте несколько объектов класса и, затем, обратитесь к ним как к функциям.
<br>
Перегрузка операторов — один из способов реализации полиморфизма, когда мы можем задать свою реализацию какого-либо метода в своём классе.

Например, у нас есть два класса:
<pre>
class A:
    def go(self):
        print('Go, A!')

class B(A):
    def go(self, name):
        print('Go, {}!'.format(name))
</pre>
В данном примере класс B наследует класс A, но переопределяет метод go, поэтому он имеет мало общего с аналогичным методом класса A.
Однако в python имеются методы, которые, как правило, не вызываются напрямую, а вызываются встроенными функциями или операторами.
Например, метод __init__ перегружает конструктор класса. 

# Конструктор - создание экземпляра класса.
<pre>
class A:
    def __init__(self, name):
        self.name = name

a = A('Vasya')
print(a.name) # Vasya
</pre>
# список магических методов.
<pre>
__new__(cls[, ...]) — управляет созданием экземпляра. В качестве обязательного аргумента принимает класс. Должен возвращать экземпляр класса для его последующей его передачи методу __init__.
__init__(self[, ...]) - конструктор.
__del__(self) - вызывается при удалении объекта сборщиком мусора.
__repr__(self) - вызывается встроенной функцией repr; возвращает "сырые" данные, использующиеся для внутреннего представления в python.
__str__(self) - вызывается функциями str, print и format. Возвращает строковое представление объекта.
__bytes__(self) - вызывается функцией bytes при преобразовании к байтам.
__format__(self, format_spec) - используется функцией format (а также методом format у строк).
__lt__(self, other) - x &lt; y вызывает x.__lt__(y).
__le__(self, other) - x ≤ y вызывает x.__le__(y).
__eq__(self, other) - x == y вызывает x.__eq__(y).
__ne__(self, other) - x != y вызывает x.__ne__(y)
__gt__(self, other) - x &gt; y вызывает x.__gt__(y).
__ge__(self, other) - x ≥ y вызывает x.__ge__(y).
__hash__(self) - получение хэш-суммы объекта, например, для добавления в словарь.
__bool__(self) - вызывается при проверке истинности. Если этот метод не определён, вызывается метод __len__ (объекты, имеющие ненулевую длину, считаются истинными).
__getattr__(self, name) - вызывается, когда атрибут экземпляра класса не найден в обычных местах (например, у экземпляра нет метода с таким названием).
__setattr__(self, name, value) - назначение атрибута.
__delattr__(self, name) - удаление атрибута (del obj.name).
__call__(self[, args...]) - вызов экземпляра класса как функции.
__len__(self) - длина объекта.
__getitem__(self, key) - доступ по индексу (или ключу).
__setitem__(self, key, value) - назначение элемента по индексу.
__delitem__(self, key) - удаление элемента по индексу.
__iter__(self) - возвращает итератор для контейнера.
__reversed__(self) - итератор из элементов, следующих в обратном порядке.
__contains__(self, item) - проверка на принадлежность элемента контейнеру (item in self).
</pre>
# Перегрузка арифметических операторов
<pre>
__add__(self, other) - сложение. x + y вызывает x.__add__(y).
__sub__(self, other) - вычитание (x - y).
__mul__(self, other) - умножение (x * y).
__truediv__(self, other) - деление (x / y).
__floordiv__(self, other) - целочисленное деление (x // y).
__mod__(self, other) - остаток от деления (x % y).
__divmod__(self, other) - частное и остаток (divmod(x, y)).
__pow__(self, other[, modulo]) - возведение в степень (x ** y, pow(x, y[, modulo])).
__lshift__(self, other) - битовый сдвиг влево (x << y).
__rshift__(self, other) - битовый сдвиг вправо (x >> y).
__and__(self, other) - битовое И (x & y).
__xor__(self, other) - битовое ИСКЛЮЧАЮЩЕЕ ИЛИ (x ^ y).
__or__(self, other) - битовое ИЛИ (x | y).


__radd__(self, other),
__rsub__(self, other),
__rmul__(self, other),
__rtruediv__(self, other),
__rfloordiv__(self, other),
__rmod__(self, other),
__rdivmod__(self, other),
__rpow__(self, other),
__rlshift__(self, other),
__rrshift__(self, other),
__rand__(self, other),
__rxor__(self, other),
__ror__(self, other) - делают то же самое, что и арифметические операторы, перечисленные выше, но для аргументов, находящихся справа, и только в случае, если для левого операнда не определён соответствующий метод.
Например, операция x + y будет сначала пытаться вызвать x.__add__(y), и только в том случае, если это не получилось, будет пытаться вызвать y.__radd__(x). Аналогично для остальных методов.


__iadd__(self, other) - +=.
__isub__(self, other) - -=.
__imul__(self, other) - *=.
__itruediv__(self, other) - /=.
__ifloordiv__(self, other) - //=.
__imod__(self, other) - %=.
__ipow__(self, other[, modulo]) - **=.
__ilshift__(self, other) - <<=.
__irshift__(self, other) - >>=.
__iand__(self, other) - &=.
__ixor__(self, other) - ^=.
__ior__(self, other) - |=.
__neg__(self) - унарный -.
__pos__(self) - унарный +.
__abs__(self) - модуль (abs()).
__invert__(self) - инверсия (~).
__complex__(self) - приведение к complex.
__int__(self) - приведение к int.
__float__(self) - приведение к float.
__round__(self[, n]) - округление.
__enter__(self), __exit__(self, exc_type, exc_value, traceback) - реализация менеджеров контекста.

</pre>
